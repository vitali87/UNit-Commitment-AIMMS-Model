## ams_version=1.0

Model UC_AIMMS_Model {
    DeclarationSection sets {
        Set UniversalSet {
            Text: "The universal set";
            Index: UniversalSet_i;
            Definition: {
                data { 'numPlant','minPower','maxPower','fixedCost','noLoadCost', 'incCost', 
                  'startCost', 'noLoadCarbon','incCarbon','startCarbon','incrementalEfficiency',
                  'AverageEfficiency','NoLoadFraction','variableOM',    
                   'StartFuel','StartTime','min_UT','min_DT','shutCost','timeStatus','GINC','GFC','VOM','CO2','STK','SU_FUEL_COLD','SD_FUEL',
                   'GSU_CO2_COLD','GSH_CO2','GRAMPUP','GRAMPDN','CostRampUP','CostRampDN','Y_MAX_CAPT','CC_FIXED','CC_OP','CC_VOM','CC_CSOLV',
                   'CC_SOLVD','CC_SOLVD_TH','CC_TRANS','m_A_g','m_B_g','m_C_g','c_A_g','c_B_g','c_C_g','H','COEF_A','COEF_B','COEF_C','C_1', 'C_2', 'C_3', 'delta_1', 'delta_2', 'delta_3',
                
                   'Min Demand (GW)', 'Peak Demand (GW)', 'Peak Supply (GW)', 'Relative to Peak Demand',
                  'Relative to Supply', 'Total Demand (TWh)', 'Cost of Supply (pondm)', 'Payment of Supply (pondm)', 'Revenue (pondm)',
                  'Profit (pondm)', 'Super Profit(pondm)', 'Gen Cost (pond/MWh)', 'Demand (GW)', 'Output (GW)', 'Spinning Capacity (GW)',
                  'Storage Spinning (GW)', 'Start ups', 'Shut downs', 'Storage Output', 'Storage Input', 'Storage Level', 'Total Cost (pondm)',
                  'Incremental Cost (pond/MWh)', 'Marginal Cost (pond/MWh)'}
            }
        }
        Set DemandProfiles {
            Text: "demand profiles (clustered)";
            Index: d;
            Definition: data { C1};
        }
        Set DemandProfiles_dynamic {
            SubsetOf: DemandProfiles;
            Text: "dynamic version of d";
            Index: dd_i;
        }
        Set Years {
            Text: "years considered";
            Index: y;
            InitialData: data { y1 };
        }
        Set DemandPeriods {
            Text: "demand periods (hours)";
            Index: t;
            Parameter: _24_;
            InitialData: data {1 .. 24};
        }
        Set Fuel {
            Text: "index of random fuel";
            Index: f;
            Definition: data { f1};
        }
        Set MaxGeneratorTypes {
            Index: g_max;
            InitialData: {
                data
                    { Large_Solar, Onshore_Wind,Offshore_Wind, Small_Solar, 
                    Nuclear_1   , Nuclear_2   ,Nuclear_3   ,Nuclear_4 , 
                    ASU_1,ASU_2,ASU_3,ASU_4,ASU_5,ASU_6,ASU_7,ASU_8,ASU_9,ASU_10,ASU_11,ASU_12,ASU_13,ASU_14,ASU_15,
                    Gas_CCS_AC_1,Gas_CCS_AC_2,Gas_CCS_AC_3,Gas_CCS_AC_4,Gas_CCS_AC_5,Gas_CCS_AC_6,Gas_CCS_AC_7,Gas_CCS_AC_7,Gas_CCS_AC_8,Gas_CCS_AC_9,Gas_CCS_AC_10,Gas_CCS_AC_11,Gas_CCS_AC_12,Gas_CCS_AC_13,Gas_CCS_AC_14,Gas_CCS_AC_15,  
                    CCGT_1,CCGT_2,CCGT_3,CCGT_4,CCGT_5,CCGT_6,CCGT_7,CCGT_8,CCGT_9,CCGT_10,CCGT_11,CCGT_12,CCGT_13,CCGT_14,CCGT_15,CCGT_16,CCGT_17,CCGT_18,CCGT_19,CCGT_20,CCGT_21,CCGT_22,CCGT_23,CCGT_24,CCGT_25,CCGT_26,CCGT_27,CCGT_28,CCGT_29,CCGT_30,CCGT_31,CCGT_32,CCGT_33,CCGT_34,CCGT_35,CCGT_36,CCGT_37,CCGT_38,CCGT_39,CCGT_40,
                    Gas_CCS_1,Gas_CCS_2,Gas_CCS_3,Gas_CCS_4,Gas_CCS_5,Gas_CCS_6,Gas_CCS_7,Gas_CCS_8,Gas_CCS_9,Gas_CCS_10,Gas_CCS_11,Gas_CCS_12,Gas_CCS_13,Gas_CCS_14,Gas_CCS_15,Gas_CCS_16,Gas_CCS_17,Gas_CCS_18,Gas_CCS_19,Gas_CCS_20,Gas_CCS_21,Gas_CCS_22,Gas_CCS_23,Gas_CCS_24,Gas_CCS_25,Gas_CCS_26,Gas_CCS_27,Gas_CCS_28,Gas_CCS_29,Gas_CCS_30,Gas_CCS_31,Gas_CCS_32,Gas_CCS_33,Gas_CCS_34,Gas_CCS_35,Gas_CCS_36,Gas_CCS_37,Gas_CCS_38,Gas_CCS_39,Gas_CCS_40,Gas_CCS_41,Gas_CCS_42,Gas_CCS_43,Gas_CCS_44,
                    OCGT_1      , OCGT_2      ,OCGT_3      , OCGT_4 ,OCGT_5  ,      OCGT_6      , OCGT_7 ,OCGT_8      , OCGT_9      , OCGT_10, OCGT_11      , OCGT_12      ,OCGT_13      , OCGT_14 ,OCGT_15  ,
                    OCGT_16      , OCGT_17 ,OCGT_18      , OCGT_19      , OCGT_20,
                    PHS,CAES,Flywheel,Flow_Battery,Hydrogen_fuel_cell, 
                    DemandResponse1,DemandResponse2,DemandResponse3,DemandResponse4,DemandResponse5,DemandResponse6,DemandResponse7, DemandResponse8,DemandResponse9,DemandResponse10, 
                    LoadShedding }
            }
        }
        Set GeneratorTypes {
            SubsetOf: MaxGeneratorTypes;
            Text: "generator types";
            Index: g;
            Definition: NonDispatchableGenerators + BaseloadGenerators + AirSeparationUnits + ACGenerators + CCGTGenerators + PCCSGenerators + OCGTGenerators + StorageGenerators + ConsumerGenerators;
        }
        Set PhysicalGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "generators that physically exist (real), i.e. conventional + storage";
            Index: rg;
            Definition: GeneratorTypes - AirSeparationUnits - ConsumerGenerators;
        }
        Set PureGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "pure generators i.e. excluding storage";
            Index: pg;
            Definition: GeneratorTypes - AirSeparationUnits - StorageGenerators - ConsumerGenerators;
        }
        Set CCGT_CCSGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "combined cycle gas turbines + gas generators with CCS + Allum Cycle plants";
            Index: ccg_ccs;
            Definition: CCGTGenerators + PCCSGenerators + ACGenerators;
        }
        Set CCSGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "Gas generators with CCS";
            Index: ccs;
            Definition: ACGenerators + PCCSGenerators;
        }
        Set NonCCSGenerators {
            SubsetOf: MaxGeneratorTypes;
            Index: nccs;
            Definition: GeneratorTypes - AirSeparationUnits - CCSGenerators;
        }
        Set ThermalGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "Thermal generators CCGT (including CCS) + OCGT";
            Index: tg;
            Definition: ACGenerators + CCGTGenerators + PCCSGenerators + OCGTGenerators;
        }
        Set NonThermalGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "Non-Thermal generator, i.e. nuc + storage + consumers in this case";
            Index: ntg;
            Definition: GeneratorTypes - AirSeparationUnits - ThermalGenerators;
        }
        Set nonStorageGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "non-storage generators excluding Allum Cycle plant";
            Index: nsg;
            Definition: GeneratorTypes - AirSeparationUnits - StorageGenerators;
        }
        Set DispatchablePureGenerators {
            SubsetOf: MaxGeneratorTypes;
            Index: dpg;
            Definition: PureGenerators - NonDispatchableGenerators;
        }
        Set DispatchablePhysicalGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "generators that physically exist (real), i.e. conventional + storage";
            Index: drg;
            Definition: PhysicalGenerators - NonDispatchableGenerators;
        }
        Set NonDispatchableGenerators {
            SubsetOf: MaxGeneratorTypes;
            Index: ndg;
            Definition: {
                data{
                Large_Solar, Onshore_Wind,Offshore_Wind, Small_Solar
                }
            }
        }
        Set BaseloadGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "Generators that are beseload, i.e. nuclear in this case";
            Index: bg;
            Definition: {
                data{
                Nuclear_1,Nuclear_2,Nuclear_3,Nuclear_4
                }
            }
        }
        Set PCCSGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "Gas generators with CCS";
            Index: pccs;
            Definition: {
                data{
                !Gas_CCS_1,Gas_CCS_2,Gas_CCS_3,Gas_CCS_4,Gas_CCS_5,Gas_CCS_6,Gas_CCS_7,Gas_CCS_8,Gas_CCS_9,Gas_CCS_10,Gas_CCS_11,Gas_CCS_12,Gas_CCS_13,Gas_CCS_14,Gas_CCS_15,Gas_CCS_16,Gas_CCS_17,Gas_CCS_18,Gas_CCS_19,Gas_CCS_20,Gas_CCS_21,Gas_CCS_22,Gas_CCS_23,Gas_CCS_24,Gas_CCS_25,Gas_CCS_26,Gas_CCS_27,Gas_CCS_28,Gas_CCS_29,Gas_CCS_30,Gas_CCS_31,Gas_CCS_32,Gas_CCS_33,Gas_CCS_34,Gas_CCS_35,Gas_CCS_36,Gas_CCS_37,Gas_CCS_38,Gas_CCS_39,Gas_CCS_40,Gas_CCS_41,Gas_CCS_42,Gas_CCS_43,Gas_CCS_44
                }
            }
        }
        Set CCGTGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "CCGT generators including CCGT_CCS";
            Index: ccg;
            Definition: {
                data {
                CCGT_1,CCGT_2,CCGT_3,CCGT_4,CCGT_5,CCGT_6,CCGT_7,CCGT_8,CCGT_9,CCGT_10,CCGT_11,CCGT_12,CCGT_13,CCGT_14,CCGT_15,CCGT_16,CCGT_17,CCGT_18,CCGT_19,CCGT_20,CCGT_21,CCGT_22,CCGT_23,CCGT_24,CCGT_25,CCGT_26,CCGT_27,CCGT_28,CCGT_29,CCGT_30,CCGT_31,CCGT_32,CCGT_33,CCGT_34,CCGT_35,CCGT_36,CCGT_37,CCGT_38,CCGT_39,CCGT_40
                }
            }
        }
        Set OCGTGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "Open-cycle gas turbines";
            Index: ocg;
            Definition: {
                data{
                OCGT_1,OCGT_2,OCGT_3,OCGT_4 ,OCGT_5,OCGT_6,OCGT_7,OCGT_8,OCGT_9,OCGT_10,OCGT_11,OCGT_12,OCGT_13,OCGT_14,OCGT_15,OCGT_16,OCGT_17,OCGT_18,OCGT_19,OCGT_20
                }
            }
        }
        Set StorageGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "generators with energy storage";
            Index: sg;
            Definition: {
                data {
                !PHS,CAES,Flywheel,Flow_Battery,Hydrogen_fuel_cell
                }
            }
        }
        Set ConsumerGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "pseudo generators on the consumer-side, and load shedding";
            Index: cg;
            Definition: {
                data{
                   ! DemandResponse1,DemandResponse2,DemandResponse3,DemandResponse4,DemandResponse5,DemandResponse6,DemandResponse7,DemandResponse8,DemandResponse9,DemandResponse10,
                   !  LoadShedding 
                     }
            }
        }
        Set AirSeparationUnits {
            SubsetOf: MaxGeneratorTypes;
            Text: "Air Separation Units";
            Index: asu;
            Definition: {
                data{
                !ASU_1,ASU_2,ASU_3,ASU_4,ASU_5,ASU_6,ASU_7,ASU_8,ASU_9,ASU_10,ASU_11,ASU_12,ASU_13,ASU_14,ASU_15
                    }
            }
        }
        Set ACGenerators {
            SubsetOf: MaxGeneratorTypes;
            Text: "Allum Cycle CCS generators";
            Index: ac;
            Definition: {
                data{
                !Gas_CCS_AC_1,Gas_CCS_AC_2,Gas_CCS_AC_3,Gas_CCS_AC_4,Gas_CCS_AC_5,Gas_CCS_AC_6,Gas_CCS_AC_7,Gas_CCS_AC_7,Gas_CCS_AC_8,Gas_CCS_AC_9,Gas_CCS_AC_10,Gas_CCS_AC_11,Gas_CCS_AC_12,Gas_CCS_AC_13,Gas_CCS_AC_14,Gas_CCS_AC_15
                }
            }
        }
        Set Pieces {
            Text: "How many pieces in piece-wise qudratic approx. of fuel costs";
            Index: pw;
            Definition: data{1..3};
        }
        Set qdVariables {
            SubsetOf: AllVariables;
            Definition: {
                   data{
                                output_,
                                productionTh,
                
                                k_CCS,
                
                                Online,
                                Started,
                                Stopped,
                                diff_UP,
                                diff_DN,
                                storageInput,
                                storageLevel,
                
                                charging,
                                discharging,
                                i,
                
                                totalCost,
                
                                sg_lambda,
                                sg_lambdaLevel,
                                sg_availLevel,
                                sg_Online_availLevel,
                
                                Status_,
                                Status_DT,
                                Add,
                                Add_DT,
                                Status_Started,
                                Status_Stopped,
                                Add_DTStatus_DT,
                
                                heat_continuation,
                                Penalty_AC,
                                Oxy_tank_level,
                                tank_leakage,
                                output_heat_continuation,
                                output_Online_ASU,
                                Online_Online_ASU,
                
                                Penalty_PCCS,
                
                                Penalty_AC_positive,
                                is_Penalty_AC_positive,
                                Penalty_AC_negative,
                                is_Penalty_AC_negative,
                
                		output_Online_ASU_heat_continuation,
                		heat_recovery,
                		output_heat_recovery
                                }
            }
        }
        Set qdConstraints {
            SubsetOf: AllConstraints;
            Definition: {
                                data{
                
                		eqProductionTh_qd,
                
                		eqMinOutput_PCCS,
                
                                eqK_CCS1,
                                eqK_CCS2,
                
                                eqDemandMet,
                                eqMinDT2,
                                eqMinDT2_initial,
                                eqMinDT2_initial_1,
                                eqMinDT2_initial_2,
                                eqMinDT3,
                                eqMinDT3_initial,
                                eqMinDT3_initial_1,
                                eqMinDT4,
                                eqMinDT4_initial,
                                eqMinDT4_initial_1,
                                eqMinUT2,
                                eqMinUT2_initial,
                                eqMinUT2_initial_1,
                                eqMinUT2_initial_2,
                                eqMinUT3,
                                eqMinUT3_initial,
                                eqMinUT3_initial_1,
                                eqMinUT4,
                                eqMinUT4_initial,
                                eqMinUT4_initial_1,
                                eqSpinningMet,
                                eqMinLimit,
                                eqMaxLimit,
                                eqStorage_available,
                                eqStorage_input1,
                                eqStorage_input2,
                                eqCharging1,
                                eqCharging2,
                                eqDischarging1,
                                eqDischarging2,
                                eqChargeDischarge,
                                eqChargeDischargeOnline,
                                eqRampUP,
                                eqRampUP_initial,
                                eqRampDN,
                                eqRampDN_initial,
                                eqDiffUPRamp,
                                eqDiffUPRamp_initial,
                                eqDiffDNRamp,
                                eqDiffDNRamp_initial,
                                calcStarts1,
                                calcStarts1_initial,
                                calcStarts2,
                                calcStarts2_initial,
                                calcStops1,
                                calcStops1_initial,
                                calcStops2,
                                calcStops2_initial,
                
                                calcStorageLevel,
                
                                eqOutput_Large_Solar,
                                eqOutput_Small_Solar,
                                eqOutput_Onshore_Wind,
                                eqOutput_Offshore_Wind,
                                eqSystemInertia,
                                eqi1,
                                eqi2,
                                eqsg_lambda1,
                                eqsg_lambda2,
                                eqsg_lambda_storageLevel1,
                                eqsg_lambda_storageLevel2,
                                eqsg_lambda_storageLevel3,
                                eqOnline_sg_availLevel1,
                                eqOnline_sg_availLevel2,
                                eqOnline_sg_availLevel3,
                                eqavailLevel,
                		eqCarbonIntensity_hour,
                		eqCarbonIntensity_period,
                                calcTotalCost_qd,
                
                                eqAdder,
                                eqStatus,
                                eqStatus_Started1,
                                eqStatus_Started2,
                                eqStatus_Started3,
                                eqStatus_Stopped1,
                                eqStatus_Stopped2,
                                eqStatus_Stopped3,
                                eqAdderDT,
                                eqStatusDT,
                                eqStatusDT_initial,
                                eqAddDTStatusDT1,
                                eqAddDTStatusDT2,
                                eqAddDTStatusDT3,
                                eqASU1,
                                eqASU2,
                                eqASU3,
                                eqASU4,
                                eqASU5,
                                eqASU6,
                                eqASU7,
                                eqASU8,
                                eqASU_AC_coupling,
                
                                eqPenalty_AC,     
                                eqOxy_tank_level,
                                eqtank_leakage,
                                eqheat_continuation1,
                                eqheat_continuation2,
                                eqoutput_heat_continuation1,
                                eqoutput_heat_continuation2,
                                eqoutput_heat_continuation3,
                                eqoutput_Online_ASU1,
                                eqoutput_Online_ASU2,
                                eqoutput_Online_ASU3,
                                eqOnline_Online_ASU1,
                                eqOnline_Online_ASU2,
                                eqOnline_Online_ASU3,
                
                                eqPenalty_PCCS,
                                eqOxy_tank_ouput,
                                eqMax_Oxy_tank_level,
                
                                eqPenalty_AC_positive1,
                                eqPenalty_AC_positive2,
                                eqPenalty_AC_positive3,
                                eqPenalty_AC_negative1,
                                eqPenalty_AC_negative2,
                                eqPenalty_AC_negative3,
                                eqis_Penalty_AC_positive1,
                                eqis_Penalty_AC_positive2,
                                eqis_Penalty_AC_negative1,
                                eqis_Penalty_AC_negative2,
                
                                eqoutput_Online_ASU_heat_continuation1,
                                eqoutput_Online_ASU_heat_continuation2,
                                eqoutput_Online_ASU_heat_continuation3,
                           	eqheat_recovery1,
                                eqheat_recovery2,
                                eqheat_continuation_heat_recovery,
                                eqoutput_heat_recovery1,
                                eqoutput_heat_recovery2,
                                eqoutput_heat_recovery3,
                
                                eqendOxy_tank_level
                                }
            }
        }
        Set pwVariables {
            SubsetOf: AllVariables;
            Definition: {
                                data{
                                output_,
                                productionTh,
                
                                z,
                                k_,
                
                                k_CCS,
                
                                Online,
                                Started,
                                Stopped,
                                diff_UP,
                                diff_DN,
                                storageInput,
                                storageLevel,
                
                                charging,
                                discharging,
                                i,
                
                                totalCost,
                
                                sg_lambda,
                                sg_lambdaLevel,
                                sg_availLevel,
                                sg_Online_availLevel,
                
                                Status_,
                                Status_DT,
                                Add,
                                Add_DT,
                                Status_Started,
                                Status_Stopped,
                                Add_DTStatus_DT,
                
                                heat_continuation,
                                Penalty_AC,
                                Oxy_tank_level,
                                tank_leakage,
                                z_heat_recovery,
                                k_heat_recovery,
                                Online_heat_recovery,
                                output_heat_continuation,
                                output_Online_ASU,
                                Online_Online_ASU,
                
                                Penalty_PCCS,
                
                                Penalty_AC_positive,
                                is_Penalty_AC_positive,
                                Penalty_AC_negative,
                                is_Penalty_AC_negative,
                
                		output_Online_ASU_heat_continuation,
                		heat_recovery,
                		output_heat_recovery
                                }
            }
        }
        Set pwConstraints {
            SubsetOf: AllConstraints;
            Definition: {
                                data{
                                eqOutput,
                                eqProductionTh_pw,
                
                                eqk_1,
                                eqk_2,
                                eqk_12,
                                eqk_23,
                                eqZ1,
                                eqZ2,
                                eqZ3,
                
                                eqMinOutput_PCCS,
                
                                eqK_CCS1,
                                eqK_CCS2,
                
                                eqDemandMet,
                                eqMinDT2,
                                eqMinDT2_initial,
                                eqMinDT2_initial_1,
                                eqMinDT2_initial_2,
                                eqMinDT3,
                                eqMinDT3_initial,
                                eqMinDT3_initial_1,
                                eqMinDT4,
                                eqMinDT4_initial,
                                eqMinDT4_initial_1,
                                eqMinUT2,
                                eqMinUT2_initial,
                                eqMinUT2_initial_1,
                                eqMinUT2_initial_2,
                                eqMinUT3,
                                eqMinUT3_initial,
                                eqMinUT3_initial_1,
                                eqMinUT4,
                                eqMinUT4_initial,
                                eqMinUT4_initial_1,
                                eqSpinningMet,
                                eqMinLimit,
                                eqMaxLimit,
                                eqStorage_available,
                                eqStorage_input1,
                                eqStorage_input2,
                                eqDischarging1,
                                eqDischarging2,
                                eqCharging1,
                                eqCharging2,
                                eqChargeDischarge,
                                eqChargeDischargeOnline,
                                eqRampUP,
                                eqRampUP_initial,
                                eqRampDN,
                                eqRampDN_initial,
                                eqDiffUPRamp,
                                eqDiffUPRamp_initial,
                                eqDiffDNRamp,
                                eqDiffDNRamp_initial,
                                calcStarts1,
                                calcStarts1_initial,
                                calcStarts2,
                                calcStarts2_initial,
                                calcStops1,
                                calcStops1_initial,
                                calcStops2,
                                calcStops2_initial,
                                calcStorageLevel,
                
                                eqOutput_Large_Solar,
                                eqOutput_Small_Solar,
                                eqOutput_Onshore_Wind,
                                eqOutput_Offshore_Wind,
                                eqSystemInertia,
                                eqi1,
                                eqi2,
                                eqsg_lambda1,
                                eqsg_lambda2,
                                eqsg_lambda_storageLevel1,
                                eqsg_lambda_storageLevel2,
                                eqsg_lambda_storageLevel3,
                                eqOnline_sg_availLevel1,
                                eqOnline_sg_availLevel2,
                                eqOnline_sg_availLevel3,
                                eqavailLevel,
                		eqCarbonintensity_hour,
                		eqCarbonIntensity_period,
                                calcTotalCost_pw,
                
                                eqAdder,
                                eqStatus,
                                eqStatus_Started1,
                                eqStatus_Started2,
                                eqStatus_Started3,
                                eqStatus_Stopped1,
                                eqStatus_Stopped2,
                                eqStatus_Stopped3,
                                eqAdderDT,
                                eqStatusDT,
                                eqStatusDT_initial,
                                eqAddDTStatusDT1,
                                eqAddDTStatusDT2,
                                eqAddDTStatusDT3,
                                eqASU1,
                                eqASU2,
                                eqASU3,
                                eqASU4,
                                eqASU5,
                                eqASU6,
                                eqASU7,
                                eqASU8,
                                eqASU_AC_coupling,
                
                                eqPenalty_AC,
                                eqOxy_tank_level,
                                eqtank_leakage,
                                eqheat_continuation1,
                                eqheat_continuation2,
                
                                eqz_heat_recovery11,
                                eqz_heat_recovery12,
                                eqz_heat_recovery13,
                                eqz_heat_recovery21,
                                eqz_heat_recovery22,
                                eqz_heat_recovery23,
                                eqz_heat_recovery31,
                                eqz_heat_recovery32,
                                eqz_heat_recovery33,
                                eqk_heat_recovery11,
                                eqk_heat_recovery12,
                                eqk_heat_recovery13,
                                eqk_heat_recovery21,
                                eqk_heat_recovery22,
                                eqk_heat_recovery23,
                                eqOnline_heat_recovery1,
                                eqOnline_heat_recovery2,
                                eqOnline_heat_recovery3,
                
                                eqoutput_heat_continuation1,
                                eqoutput_heat_continuation2,
                                eqoutput_heat_continuation3,
                                eqoutput_Online_ASU1,
                                eqoutput_Online_ASU2,
                                eqoutput_Online_ASU3,
                                eqOnline_Online_ASU1,
                                eqOnline_Online_ASU2,
                                eqOnline_Online_ASU3,
                
                                eqPenalty_PCCS,
                                eqOxy_tank_ouput,
                                eqMax_Oxy_tank_level,
                                eqPenalty_AC_positive1,
                                eqPenalty_AC_positive2,
                                eqPenalty_AC_positive3,
                                eqPenalty_AC_negative1,
                                eqPenalty_AC_negative2,
                                eqPenalty_AC_negative3,
                                eqis_Penalty_AC_positive1,
                                eqis_Penalty_AC_positive2,
                                eqis_Penalty_AC_negative1,
                                eqis_Penalty_AC_negative2,
                
                                eqoutput_Online_ASU_heat_continuation1,
                                eqoutput_Online_ASU_heat_continuation2,
                                eqoutput_Online_ASU_heat_continuation3,
                                eqheat_recovery1,
                                eqheat_recovery2,
                                eqheat_continuation_heat_recovery,
                                eqoutput_heat_recovery1,
                                eqoutput_heat_recovery2,
                                eqoutput_heat_recovery3,
                
                                eqendOxy_tank_level
                                }
            }
        }
        Set StochqdVariables {
            SubsetOf: AllVariables;
            Definition: {
                   data{
                                output_,
                                productionTh,
                
                                k_CCS,
                
                                Online,
                                Started,
                                Stopped,
                                diff_UP,
                                diff_DN,
                                storageInput,
                                storageLevel,
                
                                charging,
                                discharging,
                                i,
                
                                totalCost,
                
                                sg_lambda,
                                sg_lambdaLevel,
                                sg_availLevel,
                                sg_Online_availLevel,
                
                                Status_,
                                Status_DT,
                                Add,
                                Add_DT,
                                Status_Started,
                                Status_Stopped,
                                Add_DTStatus_DT,
                
                                heat_continuation,
                                Penalty_AC,
                                Oxy_tank_level,
                                tank_leakage,
                                output_heat_continuation,
                                output_Online_ASU,
                                Online_Online_ASU,
                
                                Penalty_PCCS,
                
                                Penalty_AC_positive,
                                is_Penalty_AC_positive,
                                Penalty_AC_negative,
                                is_Penalty_AC_negative,
                
                		output_Online_ASU_heat_continuation,
                		heat_recovery,
                		output_heat_recovery
                                }
            }
        }
        Set StochqdConstraints {
            SubsetOf: AllConstraints;
            Definition: {
                                data{
                
                		eqProductionTh_qd,
                
                		eqMinOutput_PCCS,
                
                                eqK_CCS1,
                                eqK_CCS2,
                
                                eqDemandMet,
                                eqMinDT2,
                                eqMinDT2_initial,
                                eqMinDT2_initial_1,
                                eqMinDT2_initial_2,
                                eqMinDT3,
                                eqMinDT3_initial,
                                eqMinDT3_initial_1,
                                eqMinDT4,
                                eqMinDT4_initial,
                                eqMinDT4_initial_1,
                                eqMinUT2,
                                eqMinUT2_initial,
                                eqMinUT2_initial_1,
                                eqMinUT2_initial_2,
                                eqMinUT3,
                                eqMinUT3_initial,
                                eqMinUT3_initial_1,
                                eqMinUT4,
                                eqMinUT4_initial,
                                eqMinUT4_initial_1,
                                eqSpinningMet,
                                eqMinLimit,
                                eqMaxLimit,
                                eqStorage_available,
                                eqStorage_input1,
                                eqStorage_input2,
                                eqCharging1,
                                eqCharging2,
                                eqDischarging1,
                                eqDischarging2,
                                eqChargeDischarge,
                                eqChargeDischargeOnline,
                                eqRampUP,
                                eqRampUP_initial,
                                eqRampDN,
                                eqRampDN_initial,
                                eqDiffUPRamp,
                                eqDiffUPRamp_initial,
                                eqDiffDNRamp,
                                eqDiffDNRamp_initial,
                                calcStarts1,
                                calcStarts1_initial,
                                calcStarts2,
                                calcStarts2_initial,
                                calcStops1,
                                calcStops1_initial,
                                calcStops2,
                                calcStops2_initial,
                
                                calcStorageLevel,
                
                                eqOutput_Large_Solar,
                                eqOutput_Small_Solar,
                                eqOutput_Onshore_Wind,
                                eqOutput_Offshore_Wind,
                                eqSystemInertia,
                                eqi1,
                                eqi2,
                                eqsg_lambda1,
                                eqsg_lambda2,
                                eqsg_lambda_storageLevel1,
                                eqsg_lambda_storageLevel2,
                                eqsg_lambda_storageLevel3,
                                eqOnline_sg_availLevel1,
                                eqOnline_sg_availLevel2,
                                eqOnline_sg_availLevel3,
                                eqavailLevel,
                		eqCarbonIntensity_hour,
                		eqCarbonIntensity_period,
                                calcTotalCost_qd,
                
                                eqAdder,
                                eqStatus,
                                eqStatus_Started1,
                                eqStatus_Started2,
                                eqStatus_Started3,
                                eqStatus_Stopped1,
                                eqStatus_Stopped2,
                                eqStatus_Stopped3,
                                eqAdderDT,
                                eqStatusDT,
                                eqStatusDT_initial,
                                eqAddDTStatusDT1,
                                eqAddDTStatusDT2,
                                eqAddDTStatusDT3,
                                eqASU1,
                                eqASU2,
                                eqASU3,
                                eqASU4,
                                eqASU5,
                                eqASU6,
                                eqASU7,
                                eqASU8,
                                eqASU_AC_coupling,
                
                                eqPenalty_AC,     
                                eqOxy_tank_level,
                                eqtank_leakage,
                                eqheat_continuation1,
                                eqheat_continuation2,
                                eqoutput_heat_continuation1,
                                eqoutput_heat_continuation2,
                                eqoutput_heat_continuation3,
                                eqoutput_Online_ASU1,
                                eqoutput_Online_ASU2,
                                eqoutput_Online_ASU3,
                                eqOnline_Online_ASU1,
                                eqOnline_Online_ASU2,
                                eqOnline_Online_ASU3,
                
                                eqPenalty_PCCS,
                                eqOxy_tank_ouput,
                                eqMax_Oxy_tank_level,
                
                                eqPenalty_AC_positive1,
                                eqPenalty_AC_positive2,
                                eqPenalty_AC_positive3,
                                eqPenalty_AC_negative1,
                                eqPenalty_AC_negative2,
                                eqPenalty_AC_negative3,
                                eqis_Penalty_AC_positive1,
                                eqis_Penalty_AC_positive2,
                                eqis_Penalty_AC_negative1,
                                eqis_Penalty_AC_negative2,
                
                                eqoutput_Online_ASU_heat_continuation1,
                                eqoutput_Online_ASU_heat_continuation2,
                                eqoutput_Online_ASU_heat_continuation3,
                           	eqheat_recovery1,
                                eqheat_recovery2,
                                eqheat_continuation_heat_recovery,
                                eqoutput_heat_recovery1,
                                eqoutput_heat_recovery2,
                                eqoutput_heat_recovery3,
                
                                eqendOxy_tank_level
                                }
            }
        }
        Set StochpwVariables {
            SubsetOf: AllVariables;
            Definition: {
                                data{
                                output_,
                                productionTh,
                
                                z,
                                k_,
                
                                k_CCS,
                
                                Online,
                                Started,
                                Stopped,
                                diff_UP,
                                diff_DN,
                                storageInput,
                                storageLevel,
                
                                charging,
                                discharging,
                                i,
                
                                totalCost,
                
                                sg_lambda,
                                sg_lambdaLevel,
                                sg_availLevel,
                                sg_Online_availLevel,
                
                                Status_,
                                Status_DT,
                                Add,
                                Add_DT,
                                Status_Started,
                                Status_Stopped,
                                Add_DTStatus_DT,
                
                                heat_continuation,
                                Penalty_AC,
                                Oxy_tank_level,
                                tank_leakage,
                                z_heat_recovery,
                                k_heat_recovery,
                                Online_heat_recovery,
                                output_heat_continuation,
                                output_Online_ASU,
                                Online_Online_ASU,
                
                                Penalty_PCCS,
                
                                Penalty_AC_positive,
                                is_Penalty_AC_positive,
                                Penalty_AC_negative,
                                is_Penalty_AC_negative,
                
                		output_Online_ASU_heat_continuation,
                		heat_recovery,
                		output_heat_recovery
                                }
            }
        }
        Set StochpwConstraints {
            SubsetOf: AllConstraints;
            Definition: {
                                data{
                                eqOutput,
                                eqProductionTh_pw,
                
                                eqk_1,
                                eqk_2,
                                eqk_12,
                                eqk_23,
                                eqZ1,
                                eqZ2,
                                eqZ3,
                
                                eqMinOutput_PCCS,
                
                                eqK_CCS1,
                                eqK_CCS2,
                
                                eqDemandMet,
                                eqMinDT2,
                                eqMinDT2_initial,
                                eqMinDT2_initial_1,
                                eqMinDT2_initial_2,
                                eqMinDT3,
                                eqMinDT3_initial,
                                eqMinDT3_initial_1,
                                eqMinDT4,
                                eqMinDT4_initial,
                                eqMinDT4_initial_1,
                                eqMinUT2,
                                eqMinUT2_initial,
                                eqMinUT2_initial_1,
                                eqMinUT2_initial_2,
                                eqMinUT3,
                                eqMinUT3_initial,
                                eqMinUT3_initial_1,
                                eqMinUT4,
                                eqMinUT4_initial,
                                eqMinUT4_initial_1,
                                eqSpinningMet,
                                eqMinLimit,
                                eqMaxLimit,
                                eqStorage_available,
                                eqStorage_input1,
                                eqStorage_input2,
                                eqDischarging1,
                                eqDischarging2,
                                eqCharging1,
                                eqCharging2,
                                eqChargeDischarge,
                                eqChargeDischargeOnline,
                                eqRampUP,
                                eqRampUP_initial,
                                eqRampDN,
                                eqRampDN_initial,
                                eqDiffUPRamp,
                                eqDiffUPRamp_initial,
                                eqDiffDNRamp,
                                eqDiffDNRamp_initial,
                                calcStarts1,
                                calcStarts1_initial,
                                calcStarts2,
                                calcStarts2_initial,
                                calcStops1,
                                calcStops1_initial,
                                calcStops2,
                                calcStops2_initial,
                                calcStorageLevel,
                
                                eqOutput_Large_Solar,
                                eqOutput_Small_Solar,
                                eqOutput_Onshore_Wind,
                                eqOutput_Offshore_Wind,
                                eqSystemInertia,
                                eqi1,
                                eqi2,
                                eqsg_lambda1,
                                eqsg_lambda2,
                                eqsg_lambda_storageLevel1,
                                eqsg_lambda_storageLevel2,
                                eqsg_lambda_storageLevel3,
                                eqOnline_sg_availLevel1,
                                eqOnline_sg_availLevel2,
                                eqOnline_sg_availLevel3,
                                eqavailLevel,
                		eqCarbonintensity_hour,
                		eqCarbonIntensity_period,
                                calcTotalCost_pw,
                
                                eqAdder,
                                eqStatus,
                                eqStatus_Started1,
                                eqStatus_Started2,
                                eqStatus_Started3,
                                eqStatus_Stopped1,
                                eqStatus_Stopped2,
                                eqStatus_Stopped3,
                                eqAdderDT,
                                eqStatusDT,
                                eqStatusDT_initial,
                                eqAddDTStatusDT1,
                                eqAddDTStatusDT2,
                                eqAddDTStatusDT3,
                                eqASU1,
                                eqASU2,
                                eqASU3,
                                eqASU4,
                                eqASU5,
                                eqASU6,
                                eqASU7,
                                eqASU8,
                                eqASU_AC_coupling,
                
                                eqPenalty_AC,
                                eqOxy_tank_level,
                                eqtank_leakage,
                                eqheat_continuation1,
                                eqheat_continuation2,
                
                                eqz_heat_recovery11,
                                eqz_heat_recovery12,
                                eqz_heat_recovery13,
                                eqz_heat_recovery21,
                                eqz_heat_recovery22,
                                eqz_heat_recovery23,
                                eqz_heat_recovery31,
                                eqz_heat_recovery32,
                                eqz_heat_recovery33,
                                eqk_heat_recovery11,
                                eqk_heat_recovery12,
                                eqk_heat_recovery13,
                                eqk_heat_recovery21,
                                eqk_heat_recovery22,
                                eqk_heat_recovery23,
                                eqOnline_heat_recovery1,
                                eqOnline_heat_recovery2,
                                eqOnline_heat_recovery3,
                
                                eqoutput_heat_continuation1,
                                eqoutput_heat_continuation2,
                                eqoutput_heat_continuation3,
                                eqoutput_Online_ASU1,
                                eqoutput_Online_ASU2,
                                eqoutput_Online_ASU3,
                                eqOnline_Online_ASU1,
                                eqOnline_Online_ASU2,
                                eqOnline_Online_ASU3,
                
                                eqPenalty_PCCS,
                                eqOxy_tank_ouput,
                                eqMax_Oxy_tank_level,
                                eqPenalty_AC_positive1,
                                eqPenalty_AC_positive2,
                                eqPenalty_AC_positive3,
                                eqPenalty_AC_negative1,
                                eqPenalty_AC_negative2,
                                eqPenalty_AC_negative3,
                                eqis_Penalty_AC_positive1,
                                eqis_Penalty_AC_positive2,
                                eqis_Penalty_AC_negative1,
                                eqis_Penalty_AC_negative2,
                
                                eqoutput_Online_ASU_heat_continuation1,
                                eqoutput_Online_ASU_heat_continuation2,
                                eqoutput_Online_ASU_heat_continuation3,
                                eqheat_recovery1,
                                eqheat_recovery2,
                                eqheat_continuation_heat_recovery,
                                eqoutput_heat_recovery1,
                                eqoutput_heat_recovery2,
                                eqoutput_heat_recovery3,
                
                                eqendOxy_tank_level
                                }
            }
        }
        Set CCS_profitConstraints {
            SubsetOf: AllConstraints;
            Definition: {
                data{
                eqRLO,
                eqRUP,
                
                eqRAS_level,
                eqRAS_operation,
                eqRAS_discharge1,
                eqRAS_discharge2,
                eqRAS_charge,
                
                eqbypass_r_1,
                eqbypass_r_2,
                
                eqbypass_charge,
                eqbypass_discharge,
                eqRAS_charge_r1,
                eqRAS_charge_r2,
                eqRAS_charge_r3
                }
            }
        }
        Set CCS_profitVariables {
            SubsetOf: AllVariables;
            Definition: {
                data{
                profit_CCS,
                
                r_,
                RAS_charge,
                RAS_discharge,
                RAS_level,
                bypass_,
                RAS_charge_r
                }
            }
        }
        Set iterations {
            SubsetOf: iterations_plus_one;
            Index: l;
            Definition: data {1};
        }
        Set iterations_plus_one {
            Index: lp1;
            Definition: data {1..2};
        }
        Set priority_set {
            Index: ps;
            Definition: data{1..5};
        }
        Set math_program_set {
            Index: mp;
            Definition: {
                data {
                'Objective_', 'LinearObjective', 'Incumbent', 'BestBound', 'ProgramStatus', 
                'SolverStatus', 'Iterations', 'Nodes_', 'GenTime', 'SolutionTime', 'NumberOfBranches', 
                'NumberOfFails', 'NumberOfInfeasibilities', 'SumOfInfeasibilities', 'SolverCalls', 
                'NumberOfConstraints', 'NumberOfVariables', 'NumberOfNonzeros', 'NumberOfIntegerVariables', 
                'NumberOfSOS1Constraints', 'NumberOfSOS2Constraints','NumberOfNonlinearConstraints', 
                'NumberOfNonlinearVariables', 'NumberOfNonlinearNonzeros', 'NumberOfNonlinearInstructions'
                }
            }
        }
        Set Scenarios {
            SubsetOf: AllStochasticScenarios;
            Index: sc;
        }
        Set Stages {
            SubsetOf: Integers;
            Index: st;
            Definition: data {1..2};
        }
    }
    DeclarationSection Initialisation_Parameters {
        Parameter xlsResults {
            Definition: 1;
            Comment: "scale factor for demand data - set to 1 if demand is given in GW, or 1000 if it is in MW";
        }
        Parameter lim_exec_time {
            Text: "limit execution time to some seconds";
            Default: 900;
        }
        Parameter rel_opt_tol {
            Text: "indicates relative optimality tolerance";
            Default: 0;
        }
        Parameter IS_CCGT_UT_2_hours {
            Range: binary;
            Default: 0;
        }
        Parameter IS_CCGT_DT_2_hours {
            Range: binary;
            Default: 0;
        }
        Parameter IS_CCGT_UT_3_hours {
            Range: binary;
            Default: 0;
        }
        Parameter IS_CCGT_DT_3_hours {
            Range: binary;
            Default: 0;
        }
        Parameter IS_CCGT_UT_4_hours {
            Range: binary;
            Default: 0;
        }
        Parameter IS_CCGT_DT_4_hours {
            Range: binary;
            Default: 0;
        }
        Parameter DISPATCH_METHOD_pw {
            Text: "a parameter that determines if dispatch is piece-wise linear";
            Range: binary;
            Default: 1;
        }
        Parameter demandScale {
            Definition: 1;
            Comment: "set the carbon tax - in pond/T";
        }
        Parameter CI_hour {
            Range: binary;
        }
        Parameter CCS_bypass {
            Text: "a parameter that determines if CCS bypass option is on";
            Range: binary;
            Default: 1;
        }
        Parameter CCS_interim {
            Range: binary;
            Default: 1;
        }
        Parameter AC_ASU_coupled {
            Range: binary;
            Default: 0;
        }
        Parameter Active {
            Text: "a parameter that defines which constraints are active";
            Range: binary;
            Default: 1;
        }
        Parameter optimis_horizon_option {
            Range: integer;
            Default: 0;
        }
        Parameter priority_parameter {
            IndexDomain: ps;
            Range: integer;
            Definition: {
                {'1':1, '2':2, '3':3,'2':2,'4':4,'5':2}
            }
        }
        Parameter ending_hour {
            Range: integer;
            Default: 24;
        }
        Parameter Init_Oxy_tank_level {
            IndexDomain: t;
            Default: 0;
        }
        Parameter Init_storageLevel {
            IndexDomain: (sg,t);
            Default: 0;
        }
        Parameter Init_RAS_level {
            IndexDomain: t;
            Default: 0;
        }
        ElementParameter map_AC_to_ASU {
            IndexDomain: ac;
            Range: AirSeparationUnits;
        }
        Parameter init_output {
            IndexDomain: (t,g);
        }
        Parameter init_online {
            IndexDomain: (t,g);
        }
        Parameter init_starts {
            IndexDomain: (t,g);
        }
        Parameter init_stops {
            IndexDomain: (t,g);
        }
        Parameter initial_solution {
            Range: binary;
        }
        ElementParameter ScenarioTreeMapping {
            IndexDomain: (sc,st);
            Range: AllStochasticScenarios;
            Comment: {
                "! maybe change Range to Scenarios?"
            }
        }
        ElementParameter MyStochasticUCGMP {
            Range: AllGeneratedMathematicalPrograms;
        }
        Parameter ScenarioProbability {
            IndexDomain: sc;
        }
        Parameter CommitmentStage {
            IndexDomain: t;
        }
        Parameter DispatchStage {
            IndexDomain: t;
        }
        Parameter DemandPeriodToStageMapping {
            IndexDomain: (st,t);
        }
    }
    DeclarationSection Input_Parameters {
        Parameter carbonCost {
            Text: " /tonne CO2";
            Definition: 80;
            Comment: {
                "76.20 was before
                 set the capacity of storage technologies (GW)"
            }
        }
        Parameter rate {
            IndexDomain: (f,pccs,t,d,l);
            Default: 0.9;
            Definition: 0.9;
        }
        Parameter StorageCap {
            IndexDomain: sg;
            Definition: {
                data { 
                PHS:			5,
                CAES:			0.4,
                Flywheel:		0.00025,
                Flow_Battery:		0.01,
                Hydrogen_Fuel_Cell:	0.05}
            }
        }
        Parameter storageLevelCap {
            IndexDomain: sg;
            Text: "GWh of energy storage (e.g. in reservoirs for PHS)";
            Definition: {
                data { 
                PHS:			20,
                CAES:			15,
                Flywheel:		1,
                Flow_Battery:		0.5,
                Hydrogen_Fuel_Cell:	0.5 }
            }
        }
        Parameter storageEff {
            IndexDomain: sg;
            Text: "Round trip efficiency of storage";
            Definition: {
                data { 
                PHS:			0.7482,
                CAES:			0.6,
                Flywheel:		0.92,
                Flow_Battery:		0.7128,
                Hydrogen_Fuel_Cell:	0.3186
                }
            }
        }
        Parameter storageChargeEff {
            IndexDomain: sg;
            Text: "Charging efficiency of storage";
            Definition: {
                data { 
                PHS:			0.86,
                CAES:			0.80,
                Flywheel:		1.00,
                Flow_Battery:		0.99,
                Hydrogen_Fuel_Cell:	0.54
                }
            }
        }
        Parameter storageDischargeEff {
            IndexDomain: sg;
            Text: "Discharging efficiency of storage";
            Definition: {
                data { 
                PHS:			0.87,
                CAES:			0.75,
                Flywheel:		0.92,
                Flow_Battery:		0.72,
                Hydrogen_Fuel_Cell:	0.59
                }
            }
        }
        Parameter demand {
            IndexDomain: (t,d);
            Text: "GW - national electricity demand (INDO_2002_2010_scaled ACS)";
            Property: Stochastic;
        }
        Parameter weight_ {
            IndexDomain: (y,d);
            Text: "numbers of days represented";
        }
        Parameter plant {
            IndexDomain: (g_max,UniversalSet_i);
            Text: "data for each generator type";
        }
        Parameter rfuel {
            IndexDomain: (g_max,f);
            Text: "simulated running fuel prices for each type of fuel";
        }
        Parameter sfuel {
            IndexDomain: (g_max,f);
            Text: "simulated starting fuel prices for each type of fuel";
        }
        Parameter RAS_max_level {
            Text: "Rich solvent storage tank capacity (kg) assuming charging at full plant load for one hour at 859kg/s rate (two CCS units simultaneously - max storage capacity within each unit is the same)";
            Default: 0;
            Definition: 3109500;
        }
        Parameter Oxy_tank_max_level {
            Text: "in 100 tonnes";
            Default: 0;
            Definition: 30.15629;
            Comment: "Tank volume for 8 hrs";
        }
        Parameter Fixed_Capture_Penalty {
            Text: "Penalty incurred when CCS plant captures CO2(MWe)";
            Default: 2;
        }
        Parameter RAS_charge_rate_s {
            Default: 23515.7142857;
        }
        Parameter RAS_charge_rate_i {
            Default: 757928.571429;
        }
        Parameter RAS_discharge_rate_s {
            Default: -25000;
        }
        Parameter RAS_discharge_rate_i {
            Default: 2500000;
        }
        Parameter alpha {
            Text: "This number + 1 equals to the coefficient for discharge penalty in eqPenalty_CCS";
            Default: 0.2;
        }
        Parameter solar_LF {
            IndexDomain: (t,d);
            Property: Stochastic;
        }
        Parameter wind_LF {
            IndexDomain: (t,d);
            Property: Stochastic;
        }
        Parameter inertia_level {
            Text: "min load level (GW) from rotational mass for inertia";
            Definition: 15;
        }
        Parameter carbon_intensity {
            Text: "carbon intensity level in gCO2/kWh";
            Definition: 50;
        }
        Parameter AC_continuation_penalty {
            Definition: 0.1019;
        }
        Parameter AC_gasification_compression_penalty {
            Text: "in GWh";
            Definition: 0.003922;
        }
        Parameter ASU_oxygen_penalty {
            Definition: 0.14179;
        }
        Parameter AC_liquefaction_penalty {
            Definition: 0.07376;
        }
        Parameter AC_cooling_air_penalty {
            Definition: 0;
        }
        Parameter AC_heat_recovery_efficiency {
            Definition: 0.66369;
        }
        Parameter plant_m_A_g_adder {
            Definition: 0.044;
        }
        Parameter plant_m_B_g_adder {
            Definition: 0.049;
        }
        Parameter plant_m_C_g_adder {
            Definition: 0.052;
        }
        Parameter plant_C_1_adder {
            Definition: 6.269;
        }
        Parameter plant_C_2_adder {
            Definition: 3.531;
        }
        Parameter plant_C_3_adder {
            Definition: 1.730;
        }
        Parameter eff_adder {
            IndexDomain: ac;
            Definition: 1/plant(ac,'GINC') - 1/AC_heat_recovery_efficiency;
        }
        Parameter fuel_recovery_dis_rate_adder {
            Definition: 0.0348;
        }
    }
    DeclarationSection Declaration_Reserve_margins {
        Comment: "reserve margins";
        Parameter res_UP {
            IndexDomain: (t,d);
            Text: "upwards reserve requirement";
        }
    }
    DeclarationSection Declaration_Intermediate_parameters {
        Comment: "intermediate parameters that need to be calculated";
        Parameter TotalCapacity {
            IndexDomain: g;
            Text: "MW";
        }
        Parameter TotalSupply {
            IndexDomain: (f,l);
        }
        Parameter TotalCarbon {
            IndexDomain: (f,l);
            Text: "MT";
        }
        Parameter CarbonInc {
            IndexDomain: (f,l);
            Text: "MT CO2 from power generation";
        }
        Parameter CarbonStartShut {
            IndexDomain: (f,l);
            Text: "MT CO2 from plant start-ups";
        }
        Parameter pTotalOutput {
            IndexDomain: (f,y,g,l);
            Text: "total output from each plant type (TWh)";
        }
        Parameter pTotalStarts {
            IndexDomain: (f,y,g,l);
            Text: "number of start ups for each plant type";
        }
        Parameter pHoursOnline {
            IndexDomain: (f,y,g,l);
            Text: "number of plant-hours online";
        }
        Parameter pHoursMarginal {
            IndexDomain: (f,y,g,l);
            Text: "time that each plant type was marginal (hours)";
        }
        Parameter Online_end_3 {
            IndexDomain: (g,d)|ord(d)>1;
            Range: binary;
            Default: 1;
        }
        Parameter Online_end_2 {
            IndexDomain: (g,d)|ord(d)>1;
            Range: binary;
            Default: 1;
        }
        Parameter Online_end_1 {
            IndexDomain: (g,d)|ord(d)>1;
            Range: binary;
            Default: 1;
        }
        Parameter Online_end {
            IndexDomain: (g,d)|ord(d)>1;
            Range: binary;
            Default: 1;
        }
        Parameter Output_end {
            IndexDomain: (g,d);
            Default: 0;
        }
        Parameter storageInput_end {
            IndexDomain: (sg,d);
            Default: 0;
        }
        ElementParameter myGMP {
            Range: AllGeneratedMathematicalPrograms;
        }
        Parameter b {
            IndexDomain: (f,pccs,t,d,l);
        }
        Parameter output_c_iteration {
            IndexDomain: (pccs,t,d);
            Text: "this is the output to calculate CCS output for each capture-rate iteration";
        }
        Parameter productionTh_c_iteration {
            IndexDomain: (pccs,t,d);
        }
        Parameter price_c_iteration {
            IndexDomain: (t,d);
        }
        Parameter k_CCS_c_iteration {
            IndexDomain: (pccs,t,d);
            Range: binary;
            Default: 1;
        }
        Parameter r_p_iteration {
            IndexDomain: (pccs,t,d,lp1);
            Range: [0, 0.9];
            Default: 0.9;
        }
        Parameter RAS_charge_productionTh_p_iteration {
            IndexDomain: (pccs,t,d,lp1);
            Range: nonnegative;
            Default: 0.2;
        }
        Parameter RAS_discharge_productionTh_p_iteration {
            IndexDomain: (pccs,t,d,lp1);
            Range: nonnegative;
            Default: 0;
        }
        Parameter RAS_charge_k_CCS_p_iteration {
            IndexDomain: (pccs,t,d,lp1);
            Range: binary;
            Default: 0;
        }
        Parameter RAS_discharge_k_CCS_p_iteration {
            IndexDomain: (pccs,t,d,lp1);
            Range: binary;
            Default: 0;
        }
        Parameter bypass_k_CCS_p_iteration {
            IndexDomain: (pccs,t,d,lp1);
            Range: binary;
            Default: 0;
        }
        Parameter productionTh_p_iteration {
            IndexDomain: (pccs,t,d,lp1);
            Range: nonnegative;
            Default: 0.2;
        }
        Parameter k_CCS_p_iteration {
            IndexDomain: (pccs,t,d,lp1);
            Range: binary;
            Default: 1;
        }
        Parameter RAS_discharge_p_iteration {
            IndexDomain: (pccs,t,d);
        }
        Parameter RAS_charge_r_p_iteration {
            IndexDomain: (pccs,t,d);
        }
        Parameter bypass_p_iteration {
            IndexDomain: (pccs,t,d);
        }
        Parameter r_for_calculation {
            IndexDomain: (pccs,t,d);
            Text: "adjustable capture rate of CCS used for model calculation";
            Range: [0, 0.9];
            Default: 0.9;
        }
        Parameter productionTh_for_calculation {
            IndexDomain: (pccs,t,d);
            Range: nonnegative;
        }
        Parameter k_CCS_for_calculation {
            IndexDomain: (pccs,t,d);
            Range: binary;
        }
        Parameter RAS_discharge_for_calculation {
            IndexDomain: (pccs,t,d);
        }
        Parameter RAS_charge_r_for_calculation {
            IndexDomain: (pccs,t,d);
        }
        Parameter bypass_for_calculation {
            IndexDomain: (pccs,t,d);
        }
        Parameter penalty_CCS {
            IndexDomain: (pccs,t,d);
            Range: nonnegative;
        }
    }
    DeclarationSection Declaration_Math_Program {
        Comment: {
            " model solvers
             primary model"
        }
        Variable output_ {
            IndexDomain: (g,t,d);
            Text: "GW - generator output";
            Range: nonnegative;
            Property: ReducedCost, Stochastic;
            Stage: 2;
        }
        Variable productionTh {
            IndexDomain: (tg,t,d);
            Text: "Thermal output production in GW";
            Range: free;
            Stage: 2;
        }
        Variable k_CCS {
            IndexDomain: (pccs,t,d);
            Text: "indicator if CCS plant is on or off";
            Range: binary;
        }
        Variable z {
            IndexDomain: (tg,t,d,pw);
            Text: "GW - generator output each piece-wise region";
            Range: nonnegative;
            Property: ReducedCost;
        }
        Variable k_ {
            IndexDomain: (tg,t,d,pw);
            Text: "piece indicator";
            Range: binary;
        }
        Variable Online {
            IndexDomain: (g,t,d);
            Text: "GW - unit in use (on)";
            Range: binary;
            Property: ReducedCost, Stochastic;
            Stage: 1;
        }
        Variable Started {
            IndexDomain: (g,t,d);
            Text: "GW - capacity of generators that started up for this period";
            Range: binary;
            Property: ReducedCost;
            Stage: 1;
        }
        Variable Stopped {
            IndexDomain: (g,t,d);
            Text: "GW - capacity of generators that stopped for this period";
            Range: binary;
            Property: ReducedCost;
            Stage: 1;
        }
        Variable diff_UP {
            IndexDomain: (g,t,d);
            Range: nonnegative;
            Property: ReducedCost;
            Stage: 2;
        }
        Variable diff_DN {
            IndexDomain: (g,t,d);
            Range: nonnegative;
            Property: ReducedCost;
            Stage: 2;
        }
        Variable storageInput {
            IndexDomain: (sg,t,d);
            Text: "GW - generator consumption";
            Property: ReducedCost;
            Stage: 2;
        }
        Variable storageLevel {
            IndexDomain: (sg,t,d);
            Text: "GWh - available storage in each energy reservoir";
            Range: [0, storageLevelCap(sg)];
            Property: ReducedCost;
            Stage: 2;
        }
        Variable charging {
            IndexDomain: (sg,t,d);
            Range: binary;
            Property: ReducedCost;
            Stage: 2;
        }
        Variable discharging {
            IndexDomain: (sg,t,d);
            Range: binary;
            Property: ReducedCost;
            Stage: 2;
        }
        Variable i {
            IndexDomain: (t,d);
            Text: "indicator of min load requirement for inertia";
            Range: binary;
            Property: ReducedCost;
        }
        Variable totalCost {
            Text: "pondm - total operating cost over the entire set";
            Range: free;
            Property: ReducedCost;
            Definition: {
                sum((g,t,dd_i), 
                
                !(Online(g,t,dd_i) * 0 * plant(g,'noLoadCost') + 
                
                !quick dispatch for all plants
                1000 * output_(g,t,dd_i) * (1/plant(g,'GINC')) 		 * plant(g,'GFC') +
                
                !variable operation and maintenance cost
                 plant(g,'VOM') +
                
                !cold start-up and shut-down costs (fuel + carbon)
                (plant(g,'startCost') + plant(g,'SU_FUEL_COLD') * plant(g,'GFC') + plant(g,'GSU_CO2_COLD') * carbonCost) * Started(g,t,dd_i) + 
                (plant(g,'shutCost')  + plant(g,'SD_FUEL')      * plant(g,'GFC') + plant(g,'GSH_CO2')      * carbonCost) * Stopped(g,t,dd_i) + 
                
                !ramping up and down costs
                diff_UP(g,t,dd_i) * plant(g,'CostRampUP') + diff_DN(g,t,dd_i) * plant(g,'CostRampDN') 
                
                ) + 
                
                !heat-continuation adder for ac plants
                sum((ac,t,dd_i),1000 * output_heat_recovery(ac,t,dd_i) * eff_adder(ac) * plant(ac,'GFC')) + ! eff adder is calculated in 'piece calculations' excel file 
                
                !incremental carbon cost
                sum((nccs,t,dd_i),1000 * output_(nccs,t,dd_i)*(plant(nccs,'CO2') * (1/plant(nccs,'GINC')) * carbonCost)) + ! from non-CCS plants
                sum((ccs,t,dd_i),1000 * output_(ccs,t,dd_i)*(plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT')) * carbonCost)) + ! from CCS plants ! change into r_(ccs,t,dd_i) for bi-level problem
                
                !RES curtailment costs
                sum((t,dd_i),
                
                (plant('Large_Solar','MaxPower')   * solar_LF(t,dd_i)  - output_('Large_Solar',t,dd_i))   * plant('Large_Solar','STK') +
                (plant('Small_Solar','MaxPower')   * solar_LF(t,dd_i)  - output_('Small_Solar',t,dd_i))   * plant('Small_Solar','STK') +
                (plant('Onshore_Wind','MaxPower')  * wind_LF(t,dd_i)   - output_('Onshore_Wind',t,dd_i))  * plant('Onshore_Wind','STK') +
                (plant('Offshore_Wind','MaxPower') * wind_LF(t,dd_i)   - output_('Offshore_Wind',t,dd_i)) * plant('Offshore_Wind','STK')) +
                
                !VOM and CO2 processing costs in and out of CCS plants
                sum((ccs,t,dd_i), 
                
                output_(ccs,t,dd_i) * plant(ccs, 'VOM') * 1000 + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_VOM') + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_TRANS') + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_CSOLV') * 
                !plant(ccs, 'CC_SOLVD')) ! Bill's suggested formula, shoule be commented if quadratic formula below is considered    
                ((plant(ccs, 'CC_SOLVD') - plant(ccs, 'CC_SOLVD_TH')) * plant(ccs,'Y_MAX_CAPT') + plant(ccs, 'CC_SOLVD_TH')))
            }
        }
        Variable sg_lambda {
            IndexDomain: (sg,t,d);
            Range: binary;
        }
        Variable sg_lambdaLevel {
            IndexDomain: (sg,t,d);
            Range: nonnegative;
        }
        Variable sg_availLevel {
            IndexDomain: (sg,t,d);
            Text: "available storage level that can be dishcarged in an hour";
            Range: nonnegative;
        }
        Variable sg_Online_availLevel {
            IndexDomain: (sg,t,d);
            Text: "available storage level that can be dishcarged within an hour when plant is on";
            Range: nonnegative;
        }
        Variable profit_CCS {
            Text: "profit in pounds, units should be given in MW as price is in MWh";
            Range: free;
            Definition: {
                sum((pccs,t,dd_i),
                
                (output_c_iteration(pccs,t,dd_i) * 1000 - !Gross output
                
                
                (alpha * RAS_discharge(pccs,t,dd_i) * k_CCS_c_iteration(pccs,t,dd_i) * plant(pccs,'CC_FIXED') + 						!fixed additional penalty for discharging
                
                !plant(ccs,'CC_OP') * (RAS_discharge_productionTh(ccs,t,dd_i) * 1000) * plant(ccs,'CO2') * r_(ccs,t,dd_i) + 				!operating penalty for discharging
                
                plant(pccs,'CC_OP') * (productionTh_c_iteration(pccs,t,dd_i)   * 1000) * plant(pccs,'CO2') * r_(pccs,t,dd_i) - 				!operating penalty for regenerating (steady state)
                
                plant(pccs,'CC_OP') * (productionTh_c_iteration(pccs,t,dd_i)   * 1000) * plant(pccs,'CO2') * RAS_charge_r(pccs,t,dd_i) + 			!operating penalty for charging cancels out with the operating penalty for regenerating 
                
                		      k_CCS_c_iteration(pccs,t,dd_i)      * Fixed_Capture_Penalty - 							!fixed penalty when plant captures (pumps on)
                
                bypass_(pccs,t,dd_i) * k_CCS_c_iteration(pccs,t,dd_i)      * Fixed_Capture_Penalty + 							!fixed penalty canceled out when plant bypasses (pumps off)
                
                k_CCS_c_iteration(pccs,t,dd_i) 		 * plant(pccs,'CC_FIXED'))) * 									!fixed penalty when CCS plant is on
                
                
                price_c_iteration(t,dd_i) - !electricity price
                
                
                !CCS costs
                productionTh_c_iteration(pccs,t,dd_i) * plant(pccs, 'GFC') * 1000 - !fuel costs
                
                productionTh_c_iteration(pccs,t,dd_i) * plant(pccs, 'CO2') * 1000 * carbonCost *(1 - r_(pccs,t,dd_i)) - ! carbon emission costs
                
                output_c_iteration(pccs,t,dd_i)       * plant(pccs, 'VOM') * 1000 - !operations and maintenance costs
                
                productionTh_c_iteration(pccs,t,dd_i) * plant(pccs, 'CO2') * 1000 * r_(pccs,t,dd_i) * plant(pccs,'CC_VOM') - !CO2 capture unit variable operations and maintenance costs 
                
                !productionTh_c_iteration(ccs,t,dd_i) * plant(ccs, 'CO2') * 1000 * r_(ccs,t,dd_i) * plant(ccs,'CC_TRANS') - !T&S costs which is actually assumed not to be a part of the CCS plant cost as it might, on the contrary, bring revenue if sold for EOR. 
                
                productionTh_c_iteration(pccs,t,dd_i) * plant(pccs, 'CO2') * 1000 * r_(pccs,t,dd_i) * plant(pccs, 'CC_CSOLV') * !solvent costs
                
                !plant(ccs, 'CC_SOLVD')) ! Bill's suggested formula, shoule be commented if quadratic formula below is on    
                
                ((plant(pccs, 'CC_SOLVD') - plant(pccs, 'CC_SOLVD_TH')) * r_(pccs,t,dd_i) + plant(pccs, 'CC_SOLVD_TH')))! This should be commented if Bill's formula is on'
            }
        }
        Variable r_ {
            IndexDomain: (pccs,t,d);
            Text: "CCS capture rate";
            Range: nonnegative;
            Default: 0.9;
            Property: ReducedCost;
            NonvarStatus: 0.9;
        }
        Variable RAS_charge {
            IndexDomain: (pccs,t,d);
            Range: binary;
            Priority: priority_parameter('4');
        }
        Variable RAS_discharge {
            IndexDomain: (pccs,t,d);
            Range: binary;
            Priority: priority_parameter('4');
        }
        Variable RAS_level {
            IndexDomain: (pccs,t,d);
            Range: free;
            Default: 0;
        }
        Variable bypass_ {
            IndexDomain: (pccs,t,d);
            Range: binary;
            Default: 0;
            Priority: priority_parameter('5');
        }
        Variable RAS_charge_r {
            IndexDomain: (pccs,t,d);
            Range: nonnegative;
        }
        Variable Status_ {
            IndexDomain: (g,t,d)|not Active;
            Range: {
                {-inf..inf}
            }
        }
        Variable Status_DT {
            IndexDomain: (g,t,d);
            Range: {
                {-inf..inf}
            }
            Property: ReducedCost;
        }
        Variable Add {
            IndexDomain: (g,t,d)|not Active;
            Range: {
                {-1..1}
            }
        }
        Variable Add_DT {
            IndexDomain: (g,t,d);
            Range: {
                {-1..0}
            }
        }
        Variable Status_Started {
            IndexDomain: (g,t,d)|not Active;
            Range: free;
        }
        Variable Status_Stopped {
            IndexDomain: (g,t,d)|not Active;
            Range: free;
        }
        Variable Add_DTStatus_DT {
            IndexDomain: (g,t,d);
            Range: {
                {-inf..0}
            }
        }
        Variable heat_continuation {
            IndexDomain: (ac,t,d)|not AC_ASU_coupled;
            Text: "indicator of heat continuation to the main cycle heat exchanger due to offline (almost offline as some part of it operates to provide the heat continuation) ASU";
            Range: binary;
        }
        Variable Penalty_AC {
            IndexDomain: (ac,t,d);
            Range: free;
            Property: ReducedCost;
        }
        Variable Oxy_tank_level {
            IndexDomain: (ac,t,d)|not AC_ASU_coupled;
            Text: "in 100 tonnes";
            Range: nonnegative;
            Default: 0;
            Property: ReducedCost;
        }
        Variable tank_leakage {
            IndexDomain: (ac,t,d)|not AC_ASU_coupled;
            Text: "tank leakage (in 100 tonnes) at the end of the period (e.g.hour)";
            Range: nonnegative;
        }
        Variable z_heat_recovery {
            IndexDomain: (ac,t,d,pw)|not AC_ASU_coupled;
            Range: nonnegative;
        }
        Variable k_heat_recovery {
            IndexDomain: (ac,t,d,pw)|not AC_ASU_coupled;
            Range: nonnegative;
        }
        Variable Online_heat_recovery {
            IndexDomain: (ac,t,d)|not AC_ASU_coupled;
            Range: nonnegative;
        }
        Variable output_heat_continuation {
            IndexDomain: (ac,t,d)|not AC_ASU_coupled;
            Range: nonnegative;
        }
        Variable output_Online_ASU {
            IndexDomain: (ac,t,d);
            Range: nonnegative;
        }
        Variable Online_Online_ASU {
            IndexDomain: (ac,t,d);
            Range: integer;
        }
        Variable Penalty_PCCS {
            IndexDomain: (pccs,t,d);
            Range: nonnegative;
        }
        Variable Penalty_AC_positive {
            IndexDomain: (ac,t,d);
            Range: nonnegative;
        }
        Variable is_Penalty_AC_positive {
            IndexDomain: (ac,t,d);
            Range: binary;
        }
        Variable Penalty_AC_negative {
            IndexDomain: (ac,t,d);
            Range: nonpositive;
        }
        Variable is_Penalty_AC_negative {
            IndexDomain: (ac,t,d);
            Range: binary;
        }
        Variable output_Online_ASU_heat_continuation {
            IndexDomain: (ac,t,d)|not AC_ASU_coupled;
            Range: nonnegative;
        }
        Variable heat_recovery {
            IndexDomain: (ac,t,d)|not AC_ASU_coupled;
            Text: "indicator of heat recovery in the main cycle by burning more fuel";
            Range: binary;
        }
        Variable output_heat_recovery {
            IndexDomain: (ac,t,d)|not AC_ASU_coupled;
            Range: nonnegative;
        }
        Constraint calcTotalCost_pw {
            Text: "the objective function - define total cost";
            Property: ShadowPrice;
            Definition: {
                totalCost =    
                
                !(Online(g,t,dd_i) * 0 * plant(g,'noLoadCost') + 
                
                !quick dispatch for ntg plants
                sum((ntg,t,dd_i),1000 * output_(ntg,t,dd_i) * (1/plant(ntg,'GINC')) * plant(ntg,'GFC')) +
                
                !piece-wise linear for tg plants
                sum((tg,t,dd_i),
                ((z(tg,t,dd_i,'1')           -  k_(tg,t,dd_i,'1') * 							          plant(tg,'delta_1'))  * 1000 * plant(tg,'m_A_g') + (Online(tg,t,dd_i)  			         - k_(tg,t,dd_i,'1'))          * plant(tg,'C_1') + 
                (k_(tg,t,dd_i,'1') 		* plant(tg,'delta_1') + z(tg,t,dd_i,'2')           - k_(tg,t,dd_i,'2')          * plant(tg,'delta_2'))  * 1000 * plant(tg,'m_B_g') + (k_(tg,t,dd_i,'1') 	 - k_(tg,t,dd_i,'2')) 	                               * plant(tg,'C_2') +
                (k_(tg,t,dd_i,'2') 		* plant(tg,'delta_2') + z(tg,t,dd_i,'3') 					                    )   * 1000 * plant(tg,'m_C_g') +  		     			 	          k_(tg,t,dd_i,'2')            * plant(tg,'C_3'))
                
                * plant(tg,'GFC')) +
                
                !heat-continuation adder for ac plants
                sum((ac,t,dd_i),
                ((z_heat_recovery(ac,t,dd_i,'1') - k_heat_recovery(ac,t,dd_i,'1') * 				                          plant(ac,'delta_1'))  * 1000 * plant_m_A_g_adder  + (Online_heat_recovery(ac,t,dd_i) 			  - k_heat_recovery(ac,t,dd_i,'1')) * plant_C_1_adder + ! m_A_x and C_x values are calculated in 'piece calculation' excel file
                (k_heat_recovery(ac,t,dd_i,'1')    * plant(ac,'delta_1')  + z_heat_recovery(ac,t,dd_i,'2') - k_heat_recovery(ac,t,dd_i,'2') * plant(ac,'delta_2'))  * 1000 * plant_m_B_g_adder  + (k_heat_recovery(ac,t,dd_i,'1') - k_heat_recovery(ac,t,dd_i,'2'))                         * plant_C_2_adder +
                (k_heat_recovery(ac,t,dd_i,'2')    * plant(ac,'delta_2')  + z_heat_recovery(ac,t,dd_i,'3') 					             )  * 1000 * plant_m_C_g_adder  +      			                            k_heat_recovery(ac,t,dd_i,'2')  * plant_C_3_adder)                    
                
                 * plant(ac,'GFC')) +
                
                sum((g,t,dd_i),
                
                !variable operation and maintenance cost
                plant(g,'VOM') +
                
                !cold start-up and shut-down costs (fuel + carbon)
                (plant(g,'startCost') + plant(g,'SU_FUEL_COLD') * plant(g,'GFC') + plant(g,'GSU_CO2_COLD') * carbonCost) * Started(g,t,dd_i) + 
                (plant(g,'shutCost')  + plant(g,'SD_FUEL')      * plant(g,'GFC') + plant(g,'GSH_CO2')      * carbonCost) * Stopped(g,t,dd_i) + 
                
                !ramping up and down costs
                diff_UP(g,t,dd_i) * plant(g,'CostRampUP') + diff_DN(g,t,dd_i) * plant(g,'CostRampDN'))
                
                 + 
                
                !incremental carbon cost
                sum((nccs,t,dd_i),1000 * output_(nccs,t,dd_i)*(plant(nccs,'CO2') * (1/plant(nccs,'GINC')) * carbonCost)) + ! from non-CCS plants
                sum((ccs,t,dd_i),1000 * output_(ccs,t,dd_i)*(plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT')) * carbonCost)) + ! from CCS plants ! change into r_(ccs,t,dd_i) for bi-level problem
                
                !RES curtailment costs
                sum((t,dd_i),
                
                (plant('Large_Solar','MaxPower')   * solar_LF(t,dd_i)  - output_('Large_Solar',t,dd_i))   * plant('Large_Solar','STK') +
                (plant('Small_Solar','MaxPower')   * solar_LF(t,dd_i)  - output_('Small_Solar',t,dd_i))   * plant('Small_Solar','STK') +
                (plant('Onshore_Wind','MaxPower')  * wind_LF(t,dd_i)   - output_('Onshore_Wind',t,dd_i))  * plant('Onshore_Wind','STK') +
                (plant('Offshore_Wind','MaxPower') * wind_LF(t,dd_i)   - output_('Offshore_Wind',t,dd_i)) * plant('Offshore_Wind','STK')) +
                
                !VOM and CO2 processing costs in and out of CCS plants
                sum((ccs,t,dd_i), 
                
                output_(ccs,t,dd_i) * plant(ccs, 'VOM') * 1000 + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_VOM') + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_TRANS') + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_CSOLV') * 
                !plant(ccs, 'CC_SOLVD')) ! Bill's suggested formula, shoule be commented if quadratic formula below is considered    
                ((plant(ccs, 'CC_SOLVD') - plant(ccs, 'CC_SOLVD_TH')) * plant(ccs,'Y_MAX_CAPT') + plant(ccs, 'CC_SOLVD_TH')))
            }
        }
        Constraint calcTotalCost_qd {
            Property: ShadowPrice;
            Definition: {
                totalCost =   sum((g,t,dd_i), 
                
                !(Online(g,t,dd_i) * 0 * plant(g,'noLoadCost') + 
                
                !quick dispatch for all plants
                1000 * output_(g,t,dd_i) * (1/plant(g,'GINC')) 		 * plant(g,'GFC') +
                
                !variable operation and maintenance cost
                 plant(g,'VOM') +
                
                !cold start-up and shut-down costs (fuel + carbon)
                (plant(g,'startCost') + plant(g,'SU_FUEL_COLD') * plant(g,'GFC') + plant(g,'GSU_CO2_COLD') * carbonCost) * Started(g,t,dd_i) + 
                (plant(g,'shutCost')  + plant(g,'SD_FUEL')      * plant(g,'GFC') + plant(g,'GSH_CO2')      * carbonCost) * Stopped(g,t,dd_i) + 
                
                !ramping up and down costs
                diff_UP(g,t,dd_i) * plant(g,'CostRampUP') + diff_DN(g,t,dd_i) * plant(g,'CostRampDN') 
                
                ) + 
                
                !heat-continuation adder for ac plants
                sum((ac,t,dd_i),1000 * output_heat_recovery(ac,t,dd_i) * eff_adder(ac) * plant(ac,'GFC')) + ! eff adder is calculated in 'piece calculations' excel file 
                
                !incremental carbon cost
                sum((nccs,t,dd_i),1000 * output_(nccs,t,dd_i)*(plant(nccs,'CO2') * (1/plant(nccs,'GINC')) * carbonCost)) + ! from non-CCS plants
                sum((ccs,t,dd_i),1000 * output_(ccs,t,dd_i)*(plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT')) * carbonCost)) + ! from CCS plants ! change into r_(ccs,t,dd_i) for bi-level problem
                
                !RES curtailment costs
                sum((t,dd_i),
                
                (plant('Large_Solar','MaxPower')   * solar_LF(t,dd_i)  - output_('Large_Solar',t,dd_i))   * plant('Large_Solar','STK') +
                (plant('Small_Solar','MaxPower')   * solar_LF(t,dd_i)  - output_('Small_Solar',t,dd_i))   * plant('Small_Solar','STK') +
                (plant('Onshore_Wind','MaxPower')  * wind_LF(t,dd_i)   - output_('Onshore_Wind',t,dd_i))  * plant('Onshore_Wind','STK') +
                (plant('Offshore_Wind','MaxPower') * wind_LF(t,dd_i)   - output_('Offshore_Wind',t,dd_i)) * plant('Offshore_Wind','STK')) +
                
                !VOM and CO2 processing costs in and out of CCS plants
                sum((ccs,t,dd_i), 
                
                output_(ccs,t,dd_i) * plant(ccs, 'VOM') * 1000 + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_VOM') + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_TRANS') + 
                productionTh(ccs,t,dd_i) * plant(ccs,'CO2') * 1000 * plant(ccs,'Y_MAX_CAPT') * plant(ccs,'CC_CSOLV') * 
                !plant(ccs, 'CC_SOLVD')) ! Bill's suggested formula, shoule be commented if quadratic formula below is considered    
                ((plant(ccs, 'CC_SOLVD') - plant(ccs, 'CC_SOLVD_TH')) * plant(ccs,'Y_MAX_CAPT') + plant(ccs, 'CC_SOLVD_TH')))
            }
        }
        Constraint eqOutput {
            IndexDomain: (tg,t,dd_i);
            Text: "output of thermal generators (GW) is equal to the sum of outputs in each under piece-wise approx. of fuel costs";
            Definition: output_(tg,t,dd_i) = sum(pw,z(tg,t,dd_i,pw));
        }
        Constraint eqProductionTh_pw {
            IndexDomain: (tg,t,dd_i);
            Text: "Thermal output production in GW";
            Definition: {
                productionTh(tg,t,dd_i) = (z(tg,t,dd_i,'1') - k_(tg,t,dd_i,'1') * plant(tg,'delta_1')) * plant(tg,'m_A_g') + (Online(tg,t,dd_i) - k_(tg,t,dd_i,'1')) * plant(tg,'C_1')/1000 + 
                
                (k_(tg,t,dd_i,'1') * plant(tg,'delta_1') + z(tg,t,dd_i,'2') - k_(tg,t,dd_i,'2') * plant(tg,'delta_2')) * plant(tg,'m_B_g') + (k_(tg,t,dd_i,'1') - k_(tg,t,dd_i,'2')) * plant(tg,'C_2')/1000 +
                
                (k_(tg,t,dd_i,'2') * plant(tg,'delta_2') + z(tg,t,dd_i,'3') 					     ) * plant(tg,'m_C_g') +  k_(tg,t,dd_i,'2')                      * plant(tg,'C_3')/1000
            }
        }
        Constraint eqProductionTh_qd {
            IndexDomain: (tg,t,dd_i);
            Text: "Thermal output production in GW";
            Definition: productionTh(tg,t,dd_i) = output_(tg,t,dd_i) * (1/plant(tg,'GINC'));
        }
        Constraint eqk_1 {
            IndexDomain: (tg,t,dd_i);
            Definition: k_(tg,t,dd_i,'1') <= z(tg,t,dd_i,'1')/plant(tg,'delta_1');
        }
        Constraint eqk_2 {
            IndexDomain: (tg,t,dd_i);
            Definition: k_(tg,t,dd_i,'2') <= (plant(tg,'delta_1') + z(tg,t,dd_i,'2')) / plant(tg,'delta_2');
        }
        Constraint eqk_12 {
            IndexDomain: (tg,t,dd_i);
            Definition: k_(tg,t,dd_i,'1') <= 1000 * z(tg,t,dd_i,'2');
        }
        Constraint eqk_23 {
            IndexDomain: (tg,t,dd_i);
            Definition: k_(tg,t,dd_i,'2') <= 1000 * z(tg,t,dd_i,'3');
        }
        Constraint eqZ1 {
            IndexDomain: (tg,t,dd_i);
            Definition: z(tg,t,dd_i,'1') <= plant(tg,'delta_1') * Online(tg,t,dd_i);
        }
        Constraint eqZ2 {
            IndexDomain: (tg,t,dd_i);
            Definition: z(tg,t,dd_i,'2') <= (plant(tg,'delta_2') - plant(tg,'delta_1')) * k_(tg,t,dd_i,'1');
        }
        Constraint eqZ3 {
            IndexDomain: (tg,t,dd_i);
            Definition: z(tg,t,dd_i,'3') <= (plant(tg,'delta_3') - plant(tg,'delta_2')) * k_(tg,t,dd_i,'2');
        }
        Constraint eqMinOutput_PCCS {
            IndexDomain: (pccs,t,dd_i);
            Definition: output_(pccs,t,dd_i) >= k_CCS(pccs,t,dd_i) * plant(pccs,'CC_FIXED')/1000;
        }
        Constraint eqK_CCS1 {
            IndexDomain: (pccs,t,dd_i);
            Definition: k_CCS(pccs,t,dd_i) >= output_(pccs,t,dd_i)/plant(pccs,'maxPower');
        }
        Constraint eqK_CCS2 {
            IndexDomain: (pccs,t,dd_i);
            Definition: k_CCS(pccs,t,dd_i) <= 1000 * output_(pccs,t,dd_i);
        }
        Constraint eqDemandMet {
            IndexDomain: (t,dd_i);
            Text: "the sum of output (GW) from all plant types must be equal to demand (GW) at all times";
            Property: ShadowPrice, ShadowPriceRange;
            Definition: {
                sum(ndg,output_(ndg,t,dd_i)) 				+ ! output from renewable generators
                
                sum(bg,output_(bg,t,dd_i)) 				+ ! output from baseload generators
                
                sum(pccs,output_(pccs,t,dd_i)) 				- ! output from pccs generators
                
                sum(pccs,Penalty_PCCS(pccs,t,dd_i))			+ ! positive penalty for operating ASU (taking electricity from the plant)
                
                sum(ccg,output_(ccg,t,dd_i)) 				+ ! output from CCGT generators
                
                sum(ac,output_(ac,t,dd_i)) 				- ! output from AC generators
                
                sum(ac,Penalty_AC_positive(ac,t,dd_i))			+ ! positive penalty for operating ASU (taking electricity from the plant)
                
                sum(ocg,output_(ocg,t,dd_i)) 				+ ! output from OCGT generators
                
                sum(sg,output_(sg,t,dd_i) * storageDischargeEff(sg)) 	+ ! output from storage generators
                
                sum(cg,output_(cg,t,dd_i)) 				  ! output from consumer (pseudo) generators (demand response)
                
                = 
                
                demand(t,dd_i) 						+ ! demand for electricity 
                
                sum(sg,storageInput(sg,t,dd_i)) 			- ! electricity requirement for storage recharging
                
                sum(ac,Penalty_AC_negative(ac,t,dd_i))			  ! negative penalty for operating ASU (taking electricity from the grid)
            }
            Comment: "the output of all types of plant must equal demand plus the power used for recharging storage";
        }
        Constraint eqMinDT2 {
            IndexDomain: (ccg_ccs,t,dd_i)|IS_CCGT_DT_2_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,t,dd_i) >= Online(ccg_ccs,t-2,dd_i) - Online(ccg_ccs,t-1,dd_i) - 1;
            Comment: {
                "This is for 2 hours min down-time
                Online(ccg,t++1,dd_i) <= 1 - Stopped(ccg,t,dd_i)"
            }
        }
        Constraint eqMinDT2_initial {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_DT_2_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,'1',dd_i) >= Online_end_1(ccg_ccs,dd_i) - Online_end(ccg_ccs,dd_i) - 1;
        }
        Constraint eqMinDT2_initial_1 {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_DT_2_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,'1',dd_i) >= Online_end_2(ccg_ccs,dd_i) - Online_end_1(ccg_ccs,dd_i) - 1;
        }
        Constraint eqMinDT2_initial_2 {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_DT_2_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,'1',dd_i) >= Online_end_3(ccg_ccs,dd_i) - Online_end_2(ccg_ccs,dd_i) - 1;
        }
        Constraint eqMinDT3 {
            IndexDomain: (ccg_ccs,t,dd_i)|IS_CCGT_DT_3_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,t+1,dd_i) >= Online(ccg_ccs,t-2,dd_i) - Online(ccg_ccs,t-1,dd_i) - 1;
            Comment: {
                "This is for 3 hours min down-time
                Online(ccg_ccs,t++2,dd_i) <= 1 - Stopped(ccg_ccs,t,dd_i)"
            }
        }
        Constraint eqMinDT3_initial {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_DT_3_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,'2',dd_i) >= Online_end_1(ccg_ccs,dd_i) - Online_end(ccg_ccs,dd_i) - 1;
        }
        Constraint eqMinDT3_initial_1 {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_DT_3_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,'2',dd_i) >= Online_end_2(ccg_ccs,dd_i) - Online_end_1(ccg_ccs,dd_i) - 1;
        }
        Constraint eqMinDT4 {
            IndexDomain: (ccg_ccs,t,dd_i)|IS_CCGT_DT_4_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,t+2,dd_i) >= Online(ccg_ccs,t-2,dd_i) - Online(ccg_ccs,t-1,dd_i) - 1;
            Comment: {
                "This is for 4 hours min down-time
                Online(ccg_ccs,t++3,dd_i) <= 1 - Stopped(ccg_ccs,t,dd_i)"
            }
        }
        Constraint eqMinDT4_initial {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_DT_4_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,'3',dd_i) >= Online_end_1(ccg_ccs,dd_i) - Online_end(ccg_ccs,dd_i) - 1;
        }
        Constraint eqMinDT4_initial_1 {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_DT_4_hours;
            Property: ShadowPrice;
            Definition: - Online(ccg_ccs,'4',dd_i) >= Online_end(ccg_ccs,dd_i) - Online(ccg_ccs,'1',dd_i) - 1;
        }
        Constraint eqMinUT2 {
            IndexDomain: (ccg_ccs,t,dd_i)|IS_CCGT_UT_2_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,t,dd_i) >= Online(ccg_ccs,t-1,dd_i) - Online(ccg_ccs,t-2,dd_i);
            Comment: {
                "This is for 2 hours min up-time
                Online(ccg_ccs,t++1,dd_i)>=Started(ccg_ccs,t,dd_i)"
            }
        }
        Constraint eqMinUT2_initial {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_UT_2_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,'1',dd_i) >= Online_end(ccg_ccs,dd_i) - Online_end_1(ccg_ccs,dd_i);
        }
        Constraint eqMinUT2_initial_1 {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_UT_2_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,'1',dd_i) >= Online_end_1(ccg_ccs,dd_i) - Online_end_2(ccg_ccs,dd_i);
        }
        Constraint eqMinUT2_initial_2 {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_UT_2_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,'1',dd_i) >= Online_end_2(ccg_ccs,dd_i) - Online_end_3(ccg_ccs,dd_i);
        }
        Constraint eqMinUT3 {
            IndexDomain: (ccg_ccs,t,dd_i)|IS_CCGT_UT_3_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,t+1,dd_i) >= Online(ccg_ccs,t-1,dd_i) - Online(ccg_ccs,t-2,dd_i);
            Comment: {
                "This is for 3 hours min up-time
                Online(ccg_ccs,t++2,dd_i)>=Started(ccg_ccs,t,dd_i)"
            }
        }
        Constraint eqMinUT3_initial {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_UT_3_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,'2',dd_i) >= Online_end(ccg_ccs,dd_i) - Online_end_1(ccg_ccs,dd_i);
        }
        Constraint eqMinUT3_initial_1 {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_UT_3_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,'2',dd_i) >= Online_end_1(ccg_ccs,dd_i) - Online_end_2(ccg_ccs,dd_i);
        }
        Constraint eqMinUT4 {
            IndexDomain: (ccg_ccs,t,dd_i)|IS_CCGT_UT_4_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,t+2,dd_i) >= Online(ccg_ccs,t-1,dd_i) - Online(ccg_ccs,t-2,dd_i);
            Comment: {
                "This is for 4 hours min up-time
                Online(ccg_ccs,t++3,dd_i)>=Started(ccg_ccs,t,dd_i)"
            }
        }
        Constraint eqMinUT4_initial {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_UT_4_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,'3',dd_i) >= Online_end(ccg_ccs,dd_i) - Online_end_1(ccg_ccs,dd_i);
        }
        Constraint eqMinUT4_initial_1 {
            IndexDomain: (ccg_ccs,dd_i)|IS_CCGT_UT_4_hours;
            Property: ShadowPrice;
            Definition: Online(ccg_ccs,'4',dd_i) >= Online(ccg_ccs,'1',dd_i) - Online_end(ccg_ccs,dd_i);
        }
        Constraint eqSpinningMet {
            IndexDomain: (t,dd_i);
            Text: "the maximum possible output from real plants online must exceed the requirement for spinning reserve at all times";
            Property: ShadowPrice, ShadowPriceRange;
            Definition: {
                sum(dpg,plant(dpg,'maxPower') * Online(dpg,t,dd_i)) + ! available max nominal capacity from dispatchable pure generators
                
                sum(sg, storageDischargeEff(sg) * sg_Online_availLevel(sg,t,dd_i)) - ! available capacity from storage generators
                
                sum(pccs,k_CCS(pccs,t,dd_i) * plant(pccs,'CC_FIXED')/1000) - ! mandatory fixed penalty for bypassing CO2 capture in CCGT_PCCS plant (when CCS unit can let go the incremental CO2 capture)
                
                sum(ac,Penalty_AC_positive(ac,t,dd_i)) ! mandatory electricity penalty for operating ASU unit taken from the plant
                
                >=  
                
                demand(t,dd_i) - sum(ndg,output_(ndg,t,dd_i)) +  !demand net of non-dispatchable generators (i.e. assuming renewables cannot provide reserve)
                
                sum(sg,storageInput(sg,t,dd_i)) + !storage input 
                
                res_UP(t,dd_i) - ! upwards reserve requirement calculated based on {demand, wind and solar} uncertainty
                
                sum(cg, output_(cg, t, dd_i)) -! downward reserve provided by demand (consumption) side
                
                sum(ac,Penalty_AC_negative(ac,t,dd_i)) ! mandatory electricity penalty for operating ASU unit taken from the grid
            }
            Comment: {
                "the physical capacity available must exceed demand... demand will be reduced by consumer-side
                load shedding, so we must reduce demand by their combined output"
            }
        }
        Constraint eqMinLimit {
            IndexDomain: (g,t,dd_i);
            Text: "each plant\'s output must exceed its minimum rated power at all times";
            Property: ShadowPrice;
            Definition: {
                output_(g,t,dd_i) + storageInput(g,t,dd_i) >=  plant(g,'minPower') * Online(g,t,dd_i) ! assuming storage cannot charge and discharge simultaneously
            }
        }
        Constraint eqMaxLimit {
            IndexDomain: (g,t,dd_i);
            Text: "each plant\'s output must not exceed its maximum rated power at any time";
            Property: ShadowPrice;
            Definition: {
                output_(g,t,dd_i) + storageInput(g,t,dd_i) <= plant(g,'maxPower') * Online(g,t,dd_i)! assuming storage cannot charge and discharge simultaneously
            }
        }
        Constraint eqStorage_available {
            IndexDomain: (sg,t,dd_i);
            Text: "storage plants can only provide energy (and spinning reserve) if they have energy in storage";
            Property: ShadowPrice;
            Definition: output_(sg,t,dd_i) <= Init_storageLevel(sg,t) + storageLevel(sg,t-1,dd_i);
        }
        Constraint eqStorage_input1 {
            IndexDomain: (sg,t,dd_i)|not Active;
            Text: "storage plants can only store if they are online";
            Property: ShadowPrice;
            Definition: storageInput(sg,t,dd_i) <= plant(sg,'maxPower') * charging(sg,t,dd_i);
        }
        Constraint eqStorage_input2 {
            IndexDomain: (sg,t,dd_i)|not Active;
            Text: "storage plants can only store if they are online";
            Property: ShadowPrice;
            Definition: storageInput(sg,t,dd_i) >= plant(sg,'minPower') * charging(sg,t,dd_i);
        }
        Constraint eqDischarging1 {
            IndexDomain: (sg,t,dd_i);
            Property: ShadowPrice;
            Definition: discharging(sg,t,dd_i) >= output_(sg,t,dd_i)/plant(sg,'maxPower');
        }
        Constraint eqDischarging2 {
            IndexDomain: (sg,t,dd_i);
            Property: ShadowPrice;
            Definition: discharging(sg,t,dd_i) <= output_(sg,t,dd_i) * 1000000;
        }
        Constraint eqCharging1 {
            IndexDomain: (sg,t,dd_i);
            Property: ShadowPrice;
            Definition: charging(sg,t,dd_i) >= storageInput(sg,t,dd_i)/plant(sg,'maxPower');
        }
        Constraint eqCharging2 {
            IndexDomain: (sg,t,dd_i);
            Property: ShadowPrice;
            Definition: charging(sg,t,dd_i) <= storageInput(sg,t,dd_i) * 1000000;
        }
        Constraint eqChargeDischarge {
            IndexDomain: (sg,t,dd_i)|not Active;
            Property: ShadowPrice;
            Definition: charging(sg,t,dd_i) + discharging(sg,t,dd_i) <=1;
        }
        Constraint eqChargeDischargeOnline {
            IndexDomain: (sg,t,dd_i);
            Property: ShadowPrice;
            Definition: charging(sg,t,dd_i) + discharging(sg,t,dd_i) <= Online(sg,t,dd_i);
        }
        Constraint eqRampUP {
            IndexDomain: (g,t,dd_i)|ord(t)>=2;
            Text: "ramp-up constraint for generators g";
            Property: ShadowPrice;
            Definition: output_(g,t,dd_i) - output_(g,t-1,dd_i) <= plant(g,'GRAMPUP')/1000;
        }
        Constraint eqRampUP_initial {
            IndexDomain: (g,dd_i);
            Property: ShadowPrice;
            Definition: output_(g,'1',dd_i) <= Online(g,'1',dd_i) * (plant(g,'GRAMPUP')/1000 +  Output_end(g,dd_i));
            Comment: {
                "!output_(g,\'1\',dd_i) <= Online(g,\'1\',dd_i) * plant(g,\'maxPower\')"
            }
        }
        Constraint eqRampDN {
            IndexDomain: (g,t,dd_i)|ord(t)>=2;
            Text: "ramp-down constraint for generators g";
            Property: ShadowPrice;
            Definition: output_(g,t-1,dd_i) - output_(g,t,dd_i) <= plant(g,'GRAMPDN')/1000 + (plant(g,'maxPower') - plant(g,'GRAMPDN')/1000) * Stopped(g,t,dd_i);
            Comment: {
                "When plant shut-down process starts, the steam turbine is unloaded first before the gas turbine, and it takes up to 50 minutes to completely disconnect the entire CCGT plant (Kehlofer et al.,2009).
                So, a CCGT plant can completely shut down in an hour!"
            }
        }
        Constraint eqRampDN_initial {
            IndexDomain: (g,dd_i);
            Definition: output_(g,'1',dd_i) >= Online(g,'1',dd_i) * (Output_end(g,dd_i)  - plant(g,'GRAMPDN')/1000);
        }
        Constraint eqDiffUPRamp {
            IndexDomain: (g,t,dd_i)|ord(t)>1;
            Property: ShadowPrice;
            Definition: diff_UP(g,t,dd_i) >= 1000 * (output_(g,t,dd_i) - output_(g,t-1,dd_i));
        }
        Constraint eqDiffUPRamp_initial {
            IndexDomain: (g,dd_i);
            Definition: diff_UP(g,'1',dd_i) >= 1000 * (output_(g,'1',dd_i) - Output_end(g,dd_i));
        }
        Constraint eqDiffDNRamp {
            IndexDomain: (g,t,dd_i)|ord(t)>1;
            Definition: diff_DN(g,t,dd_i ) >= 1000 * (output_(g,t-1,dd_i) - output_(g,t,dd_i));
        }
        Constraint eqDiffDNRamp_initial {
            IndexDomain: (g,dd_i);
            Definition: diff_DN(g,'1',dd_i ) >= 1000 * (Output_end(g,dd_i) - output_(g,'1',dd_i));
        }
        Constraint calcStarts1 {
            IndexDomain: (g,t,dd_i)|ord(t)>1;
            Text: "define the number of generators that started up for this period (the first equation)";
            Property: ShadowPrice;
            Definition: Started(g,t,dd_i) >=  Online(g,t,dd_i) - Online(g,t-1,dd_i);
        }
        Constraint calcStarts1_initial {
            IndexDomain: (g,dd_i);
            Property: ShadowPrice;
            Definition: Started(g,'1',dd_i) >=  Online(g,'1',dd_i) - Online_end(g,dd_i);
        }
        Constraint calcStarts2 {
            IndexDomain: (g,t,dd_i)|ord(t)>1;
            Text: "define the number of generators that started up for this period (the second equation)";
            Property: ShadowPrice;
            Definition: Started(g,t,dd_i) <= 0.9 - 0.3 * Online(g,t-1,dd_i) + 0.35 * Online(g,t,dd_i);
        }
        Constraint calcStarts2_initial {
            IndexDomain: (g,dd_i);
            Property: ShadowPrice;
            Definition: Started(g,'1',dd_i) <= 0.9 - 0.3 * Online_end(g,dd_i)  + 0.35 * Online(g,'1',dd_i);
        }
        Constraint calcStops1 {
            IndexDomain: (g,t,dd_i)|ord(t)>1;
            Text: "define the number of generators that stopped for this period (the first equation)";
            Property: ShadowPrice;
            Definition: Stopped(g,t,dd_i) >=  Online(g,t-1,dd_i) - Online(g,t,dd_i);
        }
        Constraint calcStops1_initial {
            IndexDomain: (g,dd_i);
            Definition: Stopped(g,'1',dd_i) >=  Online_end(g,dd_i)  - Online(g,'1',dd_i);
        }
        Constraint calcStops2 {
            IndexDomain: (g,t,dd_i)|ord(t)>1;
            Text: "define the number of generators that stopped for this period (the second equation)";
            Property: ShadowPrice;
            Definition: Stopped(g,t,dd_i) <= 0.9 - 0.3 * Online(g,t,dd_i) + 0.35 * Online(g,t-1,dd_i);
        }
        Constraint calcStops2_initial {
            IndexDomain: (g,dd_i);
            Definition: Stopped(g,'1',dd_i) <= 0.9 - 0.3 * Online(g,'1',dd_i) + 0.35 * Online_end(g,dd_i);
        }
        Constraint calcStorageLevel {
            IndexDomain: (sg,t,dd_i);
            Text: "calculate the storage level of the energy reservoirs";
            Property: ShadowPrice;
            Definition: storageLevel(sg,t,dd_i) =  Init_storageLevel(sg,t) + storageLevel(sg,t-1,dd_i) - output_(sg,t,dd_i) + storageInput(sg,t,dd_i) * storageChargeEff(sg);
        }
        Constraint eqOutput_Large_Solar {
            IndexDomain: (t,dd_i);
            Property: ShadowPrice;
            Definition: output_('Large_Solar',t,dd_i) <= solar_LF(t,dd_i) * plant('Large_Solar','MaxPower');
        }
        Constraint eqOutput_Small_Solar {
            IndexDomain: (t,dd_i);
            Property: ShadowPrice;
            Definition: output_('Small_Solar',t,dd_i) <= solar_LF(t,dd_i) * plant('Small_Solar','MaxPower');
        }
        Constraint eqOutput_Onshore_Wind {
            IndexDomain: (t,dd_i);
            Property: ShadowPrice;
            Definition: output_('Onshore_Wind',t,dd_i) <= wind_LF(t,dd_i) * plant('Onshore_Wind','MaxPower');
        }
        Constraint eqOutput_Offshore_Wind {
            IndexDomain: (t,dd_i);
            Property: ShadowPrice;
            Definition: output_('Offshore_Wind',t,dd_i) <= wind_LF(t,dd_i) * plant('Offshore_Wind','MaxPower');
        }
        Constraint eqSystemInertia {
            IndexDomain: (t,dd_i);
            Property: ShadowPrice;
            Definition: {
                sum(bg,output_(bg,t,dd_i)) + sum(pccs,output_(pccs,t,dd_i)) - sum(pccs,Penalty_PCCS(pccs,t,dd_i)) + sum(ac,output_(ac,t,dd_i)) - sum(ac,Penalty_AC_positive(ac,t,dd_i)) + 
                
                sum(ccg,output_(ccg,t,dd_i)) + sum(ocg,output_(ocg,t,dd_i))
                
                >= 
                
                inertia_level * i(t,dd_i) + demand(t,dd_i) * (1-i(t,dd_i)) ! satisfies min level or available demand if demand is less than min level
            }
            Comment: "Storage is not included in the inertia constraint as it\'s not able to provide inertial response although being able to provide primary and secondary responses";
        }
        Constraint eqi1 {
            IndexDomain: (t,dd_i)|not Active;
            Property: ShadowPrice;
            Definition: i(t,dd_i) >= (demand(t,dd_i) - inertia_level)/demand(t,dd_i);
        }
        Constraint eqi2 {
            IndexDomain: (t,dd_i)|not Active;
            Property: ShadowPrice;
            Definition: i(t,dd_i) <= demand(t,dd_i)/inertia_level;
        }
        Constraint eqsg_lambda1 {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_lambda(sg,t,dd_i) >= (plant(sg,'maxPower') - (Init_storageLevel(sg,t) + storageLevel(sg,t-1,dd_i) + storageInput(sg,t,dd_i) * storageChargeEff(sg)))/1000;
        }
        Constraint eqsg_lambda2 {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_lambda(sg,t,dd_i) <= 1 - ((Init_storageLevel(sg,t) + storageLevel(sg,t-1,dd_i) + storageInput(sg,t,dd_i) * storageChargeEff(sg)) - plant(sg,'maxPower')) / 1000;
        }
        Constraint eqsg_lambda_storageLevel1 {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_lambdaLevel(sg,t,dd_i) <= (Init_storageLevel(sg,t) + storageLevel(sg,t-1,dd_i) + storageInput(sg,t,dd_i) * storageChargeEff(sg)) - 10000 * (sg_lambda(sg,t,dd_i) - 1);
        }
        Constraint eqsg_lambda_storageLevel2 {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_lambdaLevel(sg,t,dd_i) >= (Init_storageLevel(sg,t) + storageLevel(sg,t-1,dd_i) + storageInput(sg,t,dd_i) * storageChargeEff(sg)) + 10000 * (sg_lambda(sg,t,dd_i) - 1);
        }
        Constraint eqsg_lambda_storageLevel3 {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_lambdaLevel(sg,t,dd_i) <= sg_lambda(sg,t,dd_i) * 10000;
        }
        Constraint eqOnline_sg_availLevel1 {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_Online_availLevel(sg,t,dd_i) <= sg_availLevel(sg,t,dd_i) - 10000 * (Online(sg,t,dd_i) - 1);
        }
        Constraint eqOnline_sg_availLevel2 {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_Online_availLevel(sg,t,dd_i) >= sg_availLevel(sg,t,dd_i) + 10000 * (Online(sg,t,dd_i) - 1);
        }
        Constraint eqOnline_sg_availLevel3 {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_Online_availLevel(sg,t,dd_i) <= Online(sg,t,dd_i) * 10000;
        }
        Constraint eqavailLevel {
            IndexDomain: (sg,t,dd_i);
            Definition: sg_availLevel(sg,t,dd_i) = sg_lambdaLevel(sg,t,dd_i) + (1 - sg_lambda(sg,t,dd_i)) * plant(sg,'maxPower');
        }
        Constraint eqCarbonIntensity_hour {
            IndexDomain: (t,dd_i)|CI_hour;
            Text: "carbon intensity should not be more than the specified level at each hour";
            Property: ShadowPrice, ShadowPriceRange;
            Definition: {
                sum(nccs, 1000 * output_(nccs,t,dd_i) * plant(nccs,'CO2') * (1/plant(nccs,'GINC'))) + ! from non-CCS plants
                
                sum(ccs, 1000 * output_(ccs,t,dd_i) * plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT'))) ! from CCS plants
                
                 <= carbon_intensity * (sum(nccs, output_(nccs,t,dd_i)) + sum(ccs, output_(ccs,t,dd_i)))
                
                !Yet, does not include startup and shutdown carbon, maybe it's not required to include?
            }
            Comment: "left side is in kgCO2/kWh, so carbon_intensity, which is in gCO2/kWh, is divided by 1000 to make it kgCO2/kWh";
        }
        Constraint eqCarbonIntensity_period {
            IndexDomain: |not CI_hour and not Active;
            Text: "carbon intensity should not be more than the specified level for the entire period (including startups and shutdowns)";
            Property: ShadowPrice, ShadowPriceRange;
            Definition: {
                sum((nccs,t,dd_i), 1000 * output_(nccs,t,dd_i) * plant(nccs,'CO2') * (1/plant(nccs,'GINC'))) + ! from non-CCS plants
                
                sum((ccs,t,dd_i), 1000 * output_(ccs,t,dd_i) * plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT'))) +! from CCS plants
                
                sum((g,t,dd_i),plant(g,'GSU_CO2_COLD') * Started(g,t,dd_i)) + sum((g,t,dd_i),plant(g,'GSH_CO2') * Stopped(g,t,dd_i))
                
                 >= carbon_intensity * (sum((nccs,t,dd_i), output_(nccs,t,dd_i)) + sum((ccs,t,dd_i), output_(ccs,t,dd_i)))
            }
            Comment: "left side is in kgCO2/kWh, so carbon_intensity, which is in gCO2/kWh, is divided by 1000 to make it kgCO2/kWh";
        }
        Constraint eqRLO {
            IndexDomain: (pccs,t,dd_i);
            Property: ShadowPrice;
            Definition: r_(pccs,t,dd_i) >=0;
        }
        Constraint eqRUP {
            IndexDomain: (pccs,t,dd_i);
            Property: ShadowPrice;
            Definition: r_(pccs,t,dd_i) <= 0.9;
        }
        Constraint eqRAS_level {
            IndexDomain: (pccs,t,dd_i);
            Definition: {
                RAS_level(pccs,t,dd_i) = Init_RAS_level(t) + RAS_level(pccs,t-1,dd_i) +
                
                			  RAS_charge(pccs,t-1,dd_i)     * (output_c_iteration(pccs,t-1,dd_i)    * RAS_charge_rate_s    * (100 / plant(pccs,'maxPower')) + RAS_charge_rate_i) - 
                
                		         (RAS_discharge(pccs,t-1,dd_i)  * (output_c_iteration(pccs,t-1,dd_i)    * RAS_discharge_rate_s * (100 / plant(pccs,'maxPower')) +  RAS_discharge_rate_i))
            }
        }
        Constraint eqRAS_operation {
            IndexDomain: (pccs,t,dd_i);
            Definition: RAS_charge(pccs,t,dd_i) + RAS_discharge(pccs,t,dd_i) <= 1;
        }
        Constraint eqRAS_discharge1 {
            IndexDomain: (pccs,t,dd_i);
            Definition: RAS_discharge(pccs,t,dd_i) <= RAS_level(pccs,t,dd_i) * 1000;
        }
        Constraint eqRAS_discharge2 {
            IndexDomain: (pccs,t,dd_i)|not Active;
            Definition: RAS_discharge(pccs,t,dd_i) <= (1 - output_c_iteration(pccs,t,dd_i)/plant(pccs,'maxPower')) * 1000;
        }
        Constraint eqRAS_charge {
            IndexDomain: (pccs,t,dd_i);
            Definition: RAS_charge(pccs,t,dd_i) <= (1 - RAS_level(pccs,t,dd_i)/RAS_max_level) * 1000;
        }
        Constraint eqbypass_r_1 {
            IndexDomain: (pccs,t,dd_i);
            Definition: bypass_(pccs,t,dd_i) <= 1 - r_(pccs,t,dd_i);
        }
        Constraint eqbypass_r_2 {
            IndexDomain: (pccs,t,dd_i);
            Definition: bypass_(pccs,t,dd_i) >= 1 - 1000 * r_(pccs,t,dd_i);
        }
        Constraint eqbypass_charge {
            IndexDomain: (pccs,t,dd_i);
            Definition: RAS_charge(pccs,t,dd_i) <= 1 - bypass_(pccs,t,dd_i);
        }
        Constraint eqbypass_discharge {
            IndexDomain: (pccs,t,dd_i);
            Definition: RAS_discharge(pccs,t,dd_i) <= 1 - bypass_(pccs,t,dd_i);
        }
        Constraint eqRAS_charge_r1 {
            IndexDomain: (pccs,t,dd_i);
            Definition: RAS_charge_r(pccs,t,dd_i) <= RAS_charge(pccs,t,dd_i);
        }
        Constraint eqRAS_charge_r2 {
            IndexDomain: (pccs,t,dd_i);
            Definition: RAS_charge_r(pccs,t,dd_i) <= r_(pccs,t,dd_i) + (1 - RAS_charge(pccs,t,dd_i)) * 1000;
        }
        Constraint eqRAS_charge_r3 {
            IndexDomain: (pccs,t,dd_i);
            Definition: RAS_charge_r(pccs,t,dd_i) >= r_(pccs,t,dd_i) + (1 - RAS_charge(pccs,t,dd_i)) * ( - 1000);
        }
        Constraint eqAdder {
            IndexDomain: (g,t,dd_i)|not Active;
            Definition: Add(g,t,dd_i) = 2 * Online(g,t,dd_i) - 1;
        }
        Constraint eqStatus {
            IndexDomain: (g,t,dd_i)|not Active;
            Definition: Status_(g,t+1,dd_i) = Status_(g,t,dd_i) - Status_Started(g,t,dd_i) - Status_Stopped(g,t,dd_i) + Add(g,t,dd_i);
            Comment: {
                "Status_(g,t+1,dd_i) = Status_(g,t,dd_i) * (1 - Started(g,t,dd_i) - Stopped(g,t,dd_i)) + Add(g,t,dd_i)! This equation is linearised"
            }
        }
        Constraint eqStatus_Started1 {
            IndexDomain: (g,t,dd_i)|not Active;
            Definition: {
                Status_Started(g,t,dd_i) <= Status_(g,t,dd_i) + (1 - Started(g,t,dd_i)) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqStatus_Started2 {
            IndexDomain: (g,t,dd_i)|not Active;
            Definition: {
                Status_Started(g,t,dd_i) >= Status_(g,t,dd_i) - (1 - Started(g,t,dd_i)) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqStatus_Started3 {
            IndexDomain: (g,t,dd_i)|not Active;
            Definition: {
                Status_Started(g,t,dd_i) <= Started(g,t,dd_i) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqStatus_Stopped1 {
            IndexDomain: (g,t,dd_i)|not Active;
            Definition: {
                Status_Stopped(g,t,dd_i) <= Status_(g,t,dd_i) + (1 - Stopped(g,t,dd_i)) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqStatus_Stopped2 {
            IndexDomain: (g,t,dd_i)|not Active;
            Definition: {
                Status_Stopped(g,t,dd_i) >= Status_(g,t,dd_i) - (1 - Stopped(g,t,dd_i)) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqStatus_Stopped3 {
            IndexDomain: (g,t,dd_i)|not Active;
            Definition: {
                Status_Stopped(g,t,dd_i) <= Stopped(g,t,dd_i) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqAdderDT {
            IndexDomain: (g,t,dd_i);
            Definition: Add_DT(g,t,dd_i) = Online(g,t,dd_i) - 1;
        }
        Constraint eqStatusDT {
            IndexDomain: (g,t,dd_i)|ord(t)<=(ending_hour - 1);
            Definition: Status_DT(g,t+1,dd_i) = - (Add_DTStatus_DT(g,t,dd_i) + Add_DT(g,t,dd_i));
            Comment: {
                "Status_DT(g,t+1,dd_i) = - (Add_DT(g,t,dd_i) * Status_DT(g,t,dd_i) + Add_DT(g,t,dd_i))! This equation is linearised"
            }
        }
        Constraint eqStatusDT_initial {
            IndexDomain: (g,dd_i);
            Definition: Status_DT(g,'1',dd_i) = 0;
        }
        Constraint eqAddDTStatusDT1 {
            IndexDomain: (g,t,dd_i);
            Definition: {
                Add_DTStatus_DT(g,t,dd_i) <= - Status_DT(g,t,dd_i) + (1 + Add_DT(g,t,dd_i)) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqAddDTStatusDT2 {
            IndexDomain: (g,t,dd_i);
            Definition: {
                Add_DTStatus_DT(g,t,dd_i) >= - Status_DT(g,t,dd_i) - (1 + Add_DT(g,t,dd_i)) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqAddDTStatusDT3 {
            IndexDomain: (g,t,dd_i);
            Definition: {
                Add_DTStatus_DT(g,t,dd_i) >= Add_DT(g,t,dd_i) * 1000 ! Increae if trying longer optimisation periods
            }
        }
        Constraint eqASU1 {
            IndexDomain: (asu,t,dd_i);
            Definition: Online(asu,t,dd_i) <= 1 - (Status_DT(asu,t,dd_i) - 1)/ending_hour;
        }
        Constraint eqASU2 {
            IndexDomain: (asu,t,dd_i)|ord(t)>=3 and ord(t)<=(ending_hour - 1);
            Definition: Online(asu,t+1,dd_i) <= 1 - (Status_DT(asu,t,dd_i) - 1)/ending_hour;
        }
        Constraint eqASU3 {
            IndexDomain: (asu,t,dd_i)|ord(t)>=5 and ord(t)<=(ending_hour - 2);
            Definition: Online(asu,t+2,dd_i) <= 1 - (Status_DT(asu,t,dd_i) - 3)/ending_hour;
        }
        Constraint eqASU4 {
            IndexDomain: (asu,t,dd_i)|ord(t)>=7 and ord(t)<=(ending_hour - 3);
            Definition: Online(asu,t+3,dd_i) <= 1 - (Status_DT(asu,t,dd_i) - 5)/ending_hour;
        }
        Constraint eqASU5 {
            IndexDomain: (asu,t,dd_i)|ord(t)>=10 and ord(t)<=(ending_hour - 4);
            Definition: Online(asu,t+4,dd_i) <= 1 - (Status_DT(asu,t,dd_i) - 8)/ending_hour;
        }
        Constraint eqASU6 {
            IndexDomain: (asu,t,dd_i)|ord(t)>=18 and ord(t)<=(ending_hour - 5);
            Definition: Online(asu,t+5,dd_i) <= 1 - (Status_DT(asu,t,dd_i) - 16)/ending_hour;
        }
        Constraint eqASU7 {
            IndexDomain: (asu,t,dd_i)|ord(t)>=22 and ord(t)<=(ending_hour - 6);
            Definition: Online(asu,t+6,dd_i) <= 1 - (Status_DT(asu,t,dd_i) - 20)/ending_hour;
        }
        Constraint eqASU8 {
            IndexDomain: (asu,t,dd_i)|ord(t)>=26 and ord(t)<=(ending_hour - 7);
            Definition: Online(asu,t+7,dd_i) <= 1 - (Status_DT(asu,t,dd_i) - 24)/ending_hour;
        }
        Constraint eqASU_AC_coupling {
            IndexDomain: (ac,t,dd_i)|AC_ASU_coupled;
            Definition: Online(ac,t,dd_i) = Online(map_AC_to_ASU(ac),t,dd_i);
        }
        Constraint eqPenalty_AC {
            IndexDomain: (ac,t,dd_i);
            Text: "in GW";
            Definition: {
                Penalty_AC(ac,t,dd_i) = (output_heat_continuation(ac,t,dd_i)/plant(ac,'maxPower') * AC_continuation_penalty + output_heat_continuation(ac,t,dd_i)/plant(ac,'maxPower') * AC_gasification_compression_penalty) + ! penalties for discharging tank + vaporising oxygen
                
                 (output_Online_ASU(ac,t,dd_i)/plant(ac,'maxPower')) * (ASU_oxygen_penalty - plant(ac,'GINC')/AC_heat_recovery_efficiency * AC_gasification_compression_penalty) + !This is a part of steady-state operation penalty which adds up to a penalty of (output_(ac,t,dd_i)/0.9) * 0.1458 when both ASU and AC are online
                
                 (output_(ac,t,dd_i)/plant(ac,'maxPower') * plant(ac,'GINC')/AC_heat_recovery_efficiency * AC_gasification_compression_penalty  - output_heat_continuation(ac,t,dd_i)/plant(ac,'maxPower') * plant(ac,'GINC')/AC_heat_recovery_efficiency * AC_gasification_compression_penalty) - !penalty for discharging tank and vaporising oxygen without heat loss to the main cycle
                
                 (Online(map_AC_to_ASU(ac),t,dd_i) * (ASU_oxygen_penalty + AC_liquefaction_penalty + AC_cooling_air_penalty) - Online_Online_ASU(ac,t,dd_i) * (ASU_oxygen_penalty + AC_liquefaction_penalty + AC_cooling_air_penalty))! charging + liquifying + (cooling air) penalties
            }
        }
        Constraint eqOxy_tank_level {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: {
                Oxy_tank_level(ac,t,dd_i) = Init_Oxy_tank_level(t) + Oxy_tank_level(ac,t-1,dd_i) + 
                
                			   (output_Online_ASU(ac,t,dd_i) - output_(ac,t,dd_i))/plant(ac,'maxPower') * Oxy_tank_max_level/8 + 
                
                			   (output_Online_ASU(ac,t,dd_i) - output_(ac,t,dd_i))/plant(ac,'maxPower') * Oxy_tank_max_level/8 * fuel_recovery_dis_rate_adder -
                
                			   (output_Online_ASU_heat_continuation(ac,t,dd_i) - output_heat_continuation(ac,t,dd_i))/plant(ac,'maxPower') * Oxy_tank_max_level/8 * fuel_recovery_dis_rate_adder +
                
                			   (Online(map_AC_to_ASU(ac),t,dd_i) - Online_Online_ASU(ac,t,dd_i)) * Oxy_tank_max_level/8 - tank_leakage(ac,t-1,dd_i)
            }
        }
        Constraint eqtank_leakage {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Text: "Storage loss  0.05%/day (0.0021%/hr) of available capacity (100 tonnes)";
            Definition: tank_leakage(ac,t,dd_i) = Oxy_tank_level(ac,t,dd_i) * 0.000021;
        }
        Constraint eqheat_continuation1 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: heat_continuation(ac,t,dd_i) <= 1 - Online(map_AC_to_ASU(ac),t,dd_i);
        }
        Constraint eqheat_continuation2 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: heat_continuation(ac,t,dd_i) <= Online(ac,t,dd_i);
        }
        Constraint eqz_heat_recovery11 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'1') <= z(ac,t,dd_i,'1') + (1 - heat_recovery(ac,t,dd_i)) * 1000;
        }
        Constraint eqz_heat_recovery12 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'1') >= z(ac,t,dd_i,'1') - (1 - heat_recovery(ac,t,dd_i)) * 1000;
        }
        Constraint eqz_heat_recovery13 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'1') <= heat_recovery(ac,t,dd_i) * 1000;
        }
        Constraint eqz_heat_recovery21 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'2') <= z(ac,t,dd_i,'2') + (1 - heat_recovery(ac,t,dd_i)) * 1000;
        }
        Constraint eqz_heat_recovery22 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'2') >= z(ac,t,dd_i,'2') - (1 - heat_recovery(ac,t,dd_i)) * 1000;
        }
        Constraint eqz_heat_recovery23 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'2') <= heat_recovery(ac,t,dd_i) * 1000;
        }
        Constraint eqz_heat_recovery31 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'3') <= z(ac,t,dd_i,'3') + (1 - heat_recovery(ac,t,dd_i)) * 1000;
        }
        Constraint eqz_heat_recovery32 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'3') >= z(ac,t,dd_i,'3') - (1 - heat_recovery(ac,t,dd_i)) * 1000;
        }
        Constraint eqz_heat_recovery33 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: z_heat_recovery(ac,t,dd_i,'3') <= heat_recovery(ac,t,dd_i) * 1000;
        }
        Constraint eqk_heat_recovery11 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: k_heat_recovery(ac,t,dd_i,'1') <= k_(ac,t,dd_i,'1');
        }
        Constraint eqk_heat_recovery12 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: k_heat_recovery(ac,t,dd_i,'1') <= heat_recovery(ac,t,dd_i);
        }
        Constraint eqk_heat_recovery13 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: k_heat_recovery(ac,t,dd_i,'1') >=  k_(ac,t,dd_i,'1') + heat_recovery(ac,t,dd_i) - 1;
        }
        Constraint eqk_heat_recovery21 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: k_heat_recovery(ac,t,dd_i,'2') <= k_(ac,t,dd_i,'2');
        }
        Constraint eqk_heat_recovery22 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: k_heat_recovery(ac,t,dd_i,'2') <= heat_recovery(ac,t,dd_i);
        }
        Constraint eqk_heat_recovery23 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: k_heat_recovery(ac,t,dd_i,'2') >=  k_(ac,t,dd_i,'2') + heat_recovery(ac,t,dd_i) - 1;
        }
        Constraint eqOnline_heat_recovery1 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: Online_heat_recovery(ac,t,dd_i) <= Online(ac,t,dd_i);
        }
        Constraint eqOnline_heat_recovery2 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: Online_heat_recovery(ac,t,dd_i) <= heat_continuation(ac,t,dd_i);
        }
        Constraint eqOnline_heat_recovery3 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: Online_heat_recovery(ac,t,dd_i) >=  Online(ac,t,dd_i) + heat_continuation(ac,t,dd_i) - 1;
        }
        Constraint eqoutput_heat_continuation1 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_heat_continuation(ac,t,dd_i) <= output_(ac,t,dd_i) + (1 - heat_continuation(ac,t,dd_i)) * 1000;
        }
        Constraint eqoutput_heat_continuation2 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_heat_continuation(ac,t,dd_i) >= output_(ac,t,dd_i) - (1 - heat_continuation(ac,t,dd_i)) * 1000;
        }
        Constraint eqoutput_heat_continuation3 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_heat_continuation(ac,t,dd_i) <= heat_continuation(ac,t,dd_i) * 1000;
        }
        Constraint eqoutput_Online_ASU1 {
            IndexDomain: (ac,t,dd_i);
            Definition: output_Online_ASU(ac,t,dd_i) <= output_(ac,t,dd_i) + (1 - Online(map_AC_to_ASU(ac),t,dd_i)) * 1000;
        }
        Constraint eqoutput_Online_ASU2 {
            IndexDomain: (ac,t,dd_i);
            Definition: output_Online_ASU(ac,t,dd_i) >= output_(ac,t,dd_i) - (1 - Online(map_AC_to_ASU(ac),t,dd_i)) * 1000;
        }
        Constraint eqoutput_Online_ASU3 {
            IndexDomain: (ac,t,dd_i);
            Definition: output_Online_ASU(ac,t,dd_i) <= Online(map_AC_to_ASU(ac),t,dd_i) * 1000;
        }
        Constraint eqOnline_Online_ASU1 {
            IndexDomain: (ac,t,dd_i);
            Definition: Online_Online_ASU(ac,t,dd_i) <= Online(ac,t,dd_i);
        }
        Constraint eqOnline_Online_ASU2 {
            IndexDomain: (ac,t,dd_i);
            Definition: Online_Online_ASU(ac,t,dd_i) <= Online(map_AC_to_ASU(ac),t,dd_i);
        }
        Constraint eqOnline_Online_ASU3 {
            IndexDomain: (ac,t,dd_i);
            Definition: Online_Online_ASU(ac,t,dd_i) >=  Online(ac,t,dd_i) + Online(map_AC_to_ASU(ac),t,dd_i) - 1;
        }
        Constraint eqPenalty_PCCS {
            IndexDomain: (pccs,t,dd_i);
            Definition: {
                Penalty_PCCS(pccs,t,dd_i) = k_CCS(pccs,t,dd_i) * plant(pccs,'CC_FIXED')/1000 + !fixed penalty
                
                             plant(pccs,'CC_OP')/1000  * productionTh(pccs,t,dd_i) * plant(pccs,'CO2') * 1000 * plant(pccs,'Y_MAX_CAPT') + !capture penalty
                
                             k_CCS(pccs,t,dd_i) * Fixed_Capture_Penalty/1000 ! fixed capture penalty (pumps)
            }
        }
        Constraint eqOxy_tank_ouput {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: Init_Oxy_tank_level(t) + Oxy_tank_level(ac,t-1,dd_i) >= output_(ac,t,dd_i)/plant(ac,'maxPower') * Oxy_tank_max_level/8 - output_Online_ASU(ac,t,dd_i)/plant(ac,'maxPower')* Oxy_tank_max_level/8;
        }
        Constraint eqMax_Oxy_tank_level {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: Oxy_tank_level(ac,t,dd_i) <= Oxy_tank_max_level;
        }
        Constraint eqPenalty_AC_positive1 {
            IndexDomain: (ac,t,dd_i);
            Definition: Penalty_AC_positive(ac,t,dd_i) >= Penalty_AC(ac,t,dd_i) - (1 - is_Penalty_AC_positive(ac,t,dd_i)) * 1000;
        }
        Constraint eqPenalty_AC_positive2 {
            IndexDomain: (ac,t,dd_i);
            Definition: Penalty_AC_positive(ac,t,dd_i) <= Penalty_AC(ac,t,dd_i) + (1 - is_Penalty_AC_positive(ac,t,dd_i)) * 1000;
        }
        Constraint eqPenalty_AC_positive3 {
            IndexDomain: (ac,t,dd_i);
            Definition: Penalty_AC_positive(ac,t,dd_i) <= is_Penalty_AC_positive(ac,t,dd_i)* 1000;
        }
        Constraint eqPenalty_AC_negative1 {
            IndexDomain: (ac,t,dd_i);
            Definition: Penalty_AC_negative(ac,t,dd_i) >= Penalty_AC(ac,t,dd_i) - (1 - is_Penalty_AC_negative(ac,t,dd_i)) * 1000;
        }
        Constraint eqPenalty_AC_negative2 {
            IndexDomain: (ac,t,dd_i);
            Definition: Penalty_AC_negative(ac,t,dd_i) <= Penalty_AC(ac,t,dd_i) + (1 - is_Penalty_AC_negative(ac,t,dd_i)) * 1000;
        }
        Constraint eqPenalty_AC_negative3 {
            IndexDomain: (ac,t,dd_i);
            Definition: Penalty_AC_negative(ac,t,dd_i) <= is_Penalty_AC_negative(ac,t,dd_i)* 1000;
        }
        Constraint eqis_Penalty_AC_positive1 {
            IndexDomain: (ac,t,dd_i);
            Definition: is_Penalty_AC_positive(ac,t,dd_i) >= Penalty_AC(ac,t,dd_i)/plant(ac,'maxPower');
        }
        Constraint eqis_Penalty_AC_positive2 {
            IndexDomain: (ac,t,dd_i);
            Definition: is_Penalty_AC_positive(ac,t,dd_i) <= 1 + Penalty_AC(ac,t,dd_i)/plant(ac,'maxPower');
        }
        Constraint eqis_Penalty_AC_negative1 {
            IndexDomain: (ac,t,dd_i);
            Definition: is_Penalty_AC_negative(ac,t,dd_i) >= - Penalty_AC(ac,t,dd_i)/plant(ac,'maxPower');
        }
        Constraint eqis_Penalty_AC_negative2 {
            IndexDomain: (ac,t,dd_i);
            Definition: is_Penalty_AC_negative(ac,t,dd_i) <= 1 - Penalty_AC(ac,t,dd_i)/plant(ac,'maxPower');
        }
        Constraint eqoutput_Online_ASU_heat_continuation1 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_Online_ASU_heat_continuation(ac,t,dd_i) <= output_Online_ASU(ac,t,dd_i) + (1 - heat_continuation(ac,t,dd_i)) * 1000;
        }
        Constraint eqoutput_Online_ASU_heat_continuation2 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_Online_ASU_heat_continuation(ac,t,dd_i) >= output_Online_ASU(ac,t,dd_i) - (1 - heat_continuation(ac,t,dd_i)) * 1000;
        }
        Constraint eqoutput_Online_ASU_heat_continuation3 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_Online_ASU_heat_continuation(ac,t,dd_i) <= heat_continuation(ac,t,dd_i) * 1000;
        }
        Constraint eqheat_recovery1 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: heat_recovery(ac,t,dd_i) <= 1 - Online(map_AC_to_ASU(ac),t,dd_i);
        }
        Constraint eqheat_recovery2 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: heat_recovery(ac,t,dd_i) <= Online(ac,t,dd_i);
        }
        Constraint eqheat_continuation_heat_recovery {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: heat_recovery(ac,t,dd_i) <= 1 - heat_continuation(ac,t,dd_i);
        }
        Constraint eqoutput_heat_recovery1 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_heat_recovery(ac,t,dd_i) <= output_(ac,t,dd_i) + (1 - heat_recovery(ac,t,dd_i)) * 1000;
        }
        Constraint eqoutput_heat_recovery2 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_heat_recovery(ac,t,dd_i) >= output_(ac,t,dd_i) - (1 - heat_recovery(ac,t,dd_i)) * 1000;
        }
        Constraint eqoutput_heat_recovery3 {
            IndexDomain: (ac,t,dd_i)|not AC_ASU_coupled;
            Definition: output_heat_recovery(ac,t,dd_i) <= heat_recovery(ac,t,dd_i) * 1000;
        }
        Constraint eqendOxy_tank_level {
            IndexDomain: (ac,t,dd_i)|ord(t)=ending_hour and not AC_ASU_coupled;
            Definition: Oxy_tank_level(ac,t,dd_i) = Init_Oxy_tank_level('1');
        }
        MathematicalProgram vitali {
            Objective: totalCost;
            Direction: minimize;
            Constraints: qdConstraints;
            Variables: qdVariables;
            Type: MIP;
        }
        MathematicalProgram CCS_profit {
            Objective: profit_CCS;
            Direction: maximize;
            Constraints: CCS_profitConstraints;
            Variables: CCS_profitVariables;
            Type: MIQP;
        }
    }
    DeclarationSection Declaration_Output {
        Comment: {
            "!Output parameters calculated throughout the model"
        }
        Parameter lambda {
            IndexDomain: (t,d);
            Default: 0;
        }
        StringParameter CSVExportDllName {
            Definition: {
                if AimmsStringConstants('Architecture') = 'x86' then
                        "CSVExport.dll"
                else
                        "CSVExport64.dll"
                endif
            }
        }
        Parameter o5_D_marginals {
            IndexDomain: (f,t,d,l);
        }
        Parameter o5_D_S_marginals {
            IndexDomain: (f,t,d,l);
        }
        Parameter o5_costResults {
            IndexDomain: (f,d,l);
        }
        Parameter o5_outputResults_net {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_outputResults_base {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_Capacity_StartedResults {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_Capacity_StoppedResults {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_Capacity_OnlineResults {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_dailyCostResults {
            IndexDomain: (f,d)|not Active;
        }
        Parameter o5_storageInputResults {
            IndexDomain: (f,sg,t,d,l);
        }
        Parameter o5_storageLevelResults {
            IndexDomain: (f,sg,t,d,l);
        }
        Parameter o5_storageEndAverage {
            IndexDomain: (f,sg);
        }
        Parameter o5_storageEndAverage2 {
            IndexDomain: (f,sg,l);
        }
        Parameter o5_sL {
            IndexDomain: (sg,d);
        }
        Parameter o5_general_parameters {
            IndexDomain: (f,d,t,l,UniversalSet_i);
            Text: "summary of general parameters per time period";
        }
        Parameter o5_statsOnline {
            IndexDomain: (f,d,t,g,l);
            Text: "summary of plants online per time period";
        }
        Parameter o5_statsStarts {
            IndexDomain: (f,d,t,g,l);
            Text: "summary of plant start-ups per time period";
        }
        Parameter o5_statsStops {
            IndexDomain: (f,d,t,g,l);
            Text: "summary of plant shut-downs per time period";
        }
        Parameter o5_statsStartsStops {
            IndexDomain: (f,d,t,g,l);
            Text: "summary of plant start-ups and shut-downs per time period";
        }
        Parameter o5_statsOutput_base {
            IndexDomain: (f,d,t,g,l);
            Text: "summary of plant output per time period";
        }
        Parameter o5_statsOutput_net {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_statsInput {
            IndexDomain: (f,d,t,sg,l);
            Text: "summary of storage input per time period";
        }
        Parameter o5_statsStorage {
            IndexDomain: (f,d,t,sg,l);
            Text: "summary of storage energy per time period";
        }
        Parameter o5_ave_storage_level {
            IndexDomain: (f,sg);
            Text: "average storage level at the end of the day";
        }
        Parameter o5_eqMinLimit {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_eqMaxLimit {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_eqDiffUPRamp {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_eqDiffUPRamp_initial {
            IndexDomain: (f,g,d,l);
        }
        Parameter o5_eqDiffDNRamp {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_eqDiffDNRamp_initial {
            IndexDomain: (f,g,d,l);
        }
        Parameter o5_marginal_eqMinLimit {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_marginal_eqMaxLimit {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_marginal_eqDiffUPRamp {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_marginal_eqDiffUPRamp_initial {
            IndexDomain: (f,d,g,l);
        }
        Parameter o5_marginal_eqDiffDNRamp {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_marginal_eqDiffDNRamp_initial {
            IndexDomain: (f,d,g,l);
        }
        Parameter o5_capture_rate {
            IndexDomain: (pccs,f,t,d);
            Range: [0, 0.9];
        }
        Parameter o5_reserve_UP {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_statsReserve_UP {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_eqRampUP {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_eqRampUP_initial {
            IndexDomain: (f,g,d,l);
        }
        Parameter o5_eqRampDN {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_eqRampDN_initial {
            IndexDomain: (f,g,d,l);
        }
        Parameter o5_marginal_eqRampUP {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_marginal_eqRampUP_initial {
            IndexDomain: (f,d,g,l);
        }
        Parameter o5_marginal_eqRampDN {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_marginal_eqRampDN_initial {
            IndexDomain: (f,d,g,l);
        }
        Parameter o5_large_solar_curtailment {
            IndexDomain: (f,d,t,l);
        }
        Parameter o5_small_solar_curtailment {
            IndexDomain: (f,d,t,l);
        }
        Parameter o5_onshore_wind_curtailment {
            IndexDomain: (f,d,t,l);
        }
        Parameter o5_offshore_wind_curtailment {
            IndexDomain: (f,d,t,l);
        }
        Parameter o5_r {
            IndexDomain: (pccs,t,d,l);
            Default: 0.9;
        }
        Parameter o5_RAS_level {
            IndexDomain: (f,pccs,t,d,l);
        }
        Parameter o5_RAS_charge {
            IndexDomain: (f,pccs,t,d,l);
        }
        Parameter o5_RAS_discharge {
            IndexDomain: (f,pccs,t,d,l);
        }
        Parameter o5_bypass {
            IndexDomain: (f,pccs,t,d,l);
        }
        Parameter o5_penalty_level {
            IndexDomain: (f,pccs,t,d,l);
        }
        Parameter o5_carbon_intensity_hour {
            IndexDomain: (f,t,d);
        }
        Parameter o5_carbon_intensity_period {
            IndexDomain: (f,l);
        }
        Parameter o5_carbon_intensity_period_SUSD {
            IndexDomain: (f,l);
        }
        Parameter o5_Status_DT {
            IndexDomain: (f,g,t,d,l);
        }
        Parameter o5_Status_down {
            IndexDomain: (f,d,t,g,l);
        }
        Parameter o5_heat_continuation {
            IndexDomain: (f,d,t,ac,l);
        }
        Parameter o5_charging {
            IndexDomain: (f,d,t,sg,l);
        }
        Parameter o5_discharging {
            IndexDomain: (f,d,t,sg,l);
        }
        Parameter o5_Penalty_AC {
            IndexDomain: (f,d,t,ac,l);
        }
        Parameter o5_Oxy_tank_level {
            IndexDomain: (f,d,t,ac,l);
        }
        Parameter o5_tank_leakage {
            IndexDomain: (f,d,t,ac,l);
        }
        Parameter o5_Penalty_PCCS {
            IndexDomain: (f,d,t,pccs,l);
        }
        Parameter o5_math_program_numbers {
            IndexDomain: mp;
        }
        StringParameter o5_math_program_string {
            IndexDomain: mp;
        }
    }
    DeclarationSection Declaration_Stochastic_Output {
        Comment: {
            "!Output parameters calculated throughout the model"
        }
        Parameter o5_Stoch_onlineResults {
            IndexDomain: (sc,f,g,t,d,l);
        }
        Parameter o5_Stoch_outputResults {
            IndexDomain: (sc,f,g,t,d,l);
        }
        Parameter o5_Stoch_totalCost {
            IndexDomain: sc;
        }
        Parameter o5_Stoch_TotalObjective;
        Parameter o5_Stoch_demand {
            IndexDomain: (sc,t,d);
        }
        Parameter o5_Stoch_solar_LF {
            IndexDomain: (sc,t,d);
        }
        Parameter o5_Stoch_wind_LF {
            IndexDomain: (sc,t,d);
        }
    }
    DeclarationSection Declaration_Scenario_Generation_by_Tree {
        ElementParameter InitializeStochasticDataCallbackFunction {
            Range: AllIdentifiers;
            Default: 'InitializeStochasticDataCallback';
        }
        ElementParameter InitializeChildBranchesCallbackFunction {
            Range: AllIdentifiers;
            Default: 'InitializeChildBranchesCallback';
        }
        ElementParameter InitializeNewScenarioCallbackFunction {
            Range: AllIdentifiers;
            Default: 'InitializeNewScenarioCallback';
        }
    }
    Procedure InitializeNewScenarioCallback {
        Arguments: (CurrentStage,Scenario,RepresentativeScenario);
        Body: {
            for (t| DispatchStage(t)= CurrentStage) do
            	demand.Stochastic(Scenario,t,d)   := demand.Stochastic(RepresentativeScenario,t,d);
            	solar_LF.Stochastic(Scenario,t,d) := solar_LF.Stochastic(RepresentativeScenario,t,d);
            	wind_LF.Stochastic(Scenario,t,d)  := wind_LF.Stochastic(RepresentativeScenario,t,d);
            endfor;
        }
        ElementParameter CurrentStage {
            Range: ScenGen::AllStages;
            Property: Input;
        }
        ElementParameter Scenario {
            Range: ScenGen::AllScenarios;
            Property: Input;
        }
        ElementParameter RepresentativeScenario {
            Range: ScenGen::AllScenarios;
            Property: Input;
        }
    }
    Procedure InitializeStochasticDataCallback {
        Arguments: (CurrentStage,Scenario,ChildBranch,ChildBranchName);
        Body: {
            ! Initialize stochastic data for all periods corresponding to the current stage (and scenario)
            
            for ( t | CommitmentStage(t) = CurrentStage) do
            	demand.Stochastic(Scenario,t,d) := demand(t,d);
            	solar_LF.Stochastic(Scenario,t,d):= solar_LF(t,d);
            	wind_LF.Stochastic(Scenario,t,d):= wind_LF(t,d);
            endfor;
            
            for ( t | DispatchStage(t) = CurrentStage) do
            	demand.Stochastic(Scenario,t,d) := 
            	if(ChildBranch = 1) then 
            	 Uniform(1,1.2) * demand(t,d)!Uniform(40,50)!High demand level
            	else !i.e. (ChildBranch =2)
            	 Uniform(0.8,1) * demand(t,d)!Uniform(30,40)!Low demand level
            	endif;
            
            	solar_LF.Stochastic(Scenario,t,d):= 
            	if(ChildBranch = 1) then 
            	 Uniform(1,1.4) * solar_LF(t,d)!Uniform(40,50)!High demand level
            	else !i.e. (ChildBranch =2)
            	 Uniform(0.6,1) * solar_LF(t,d)!Uniform(30,40)!Low demand level
            	endif;
            
            	wind_LF.Stochastic(Scenario,t,d):= 
            	if(ChildBranch = 1) then 
            	 Uniform(1,1.5) * wind_LF(t,d)!Uniform(40,50)!High demand level
            	else !i.e. (ChildBranch =2)
            	 Uniform(0.5,1) * wind_LF(t,d)!Uniform(30,40)!Low demand level
            	endif;
            
            endfor;
            
            return /*relative weight*/ 1;
        }
        ElementParameter CurrentStage {
            Range: ScenGen::AllStages;
            Property: Input;
        }
        ElementParameter Scenario {
            Range: ScenGen::AllScenarios;
            Property: Input;
        }
        ElementParameter ChildBranch {
            Range: Integers;
            Property: Input;
        }
        StringParameter ChildBranchName {
            Property: Input;
        }
    }
    Procedure InitializeChildBranchesCallback {
        Arguments: (CurrentStage,Scenario,ChildBranches,ChildBranchNames);
        Body: {
            ChildBranches :={1,2};
            ChildBranchNames('1') :="H";
            ChildBranchNames('2') :="L";
        }
        Set ChildBranches {
            SubsetOf: Integers;
            Index: cb;
            Property: Output;
        }
        ElementParameter Scenario {
            Range: ScenGen::AllScenarios;
            Property: Input;
        }
        ElementParameter CurrentStage {
            Range: ScenGen::AllStages;
            Property: Input;
        }
        StringParameter ChildBranchNames {
            IndexDomain: cb;
            Property: Output;
        }
    }
    Procedure CreateScenarioTree {
        Arguments: (Stages,Scenarios,ScenarioProbability,ScenarioTreeMapping);
        Body: {
            empty ScenGen::AllScenarios;
            cleandependents ScenGen::AllScenarios;
            
            ScenGen::AllStages := Stages;
            
            ScenarioCount := 1;
            
            SetElementAdd( ScenGen::AllScenarios, RootScenario, "root" );
            FirstStage := first(ScenGen::AllStages);
            ScenGen::ScenarioGenerationTreeMapping(RootScenario,FirstStage) := RootScenario;
            ScenGen::ScenarioGenerationProbability(ScenGen::s) := 1;
            PreviousStages := first(ScenGen::AllStages);
            ChildBranchAdded := 0;
            
            Apply( InitializeStochasticDataCallbackFunction, FirstStage, RootScenario, 0, "root" );
            
            for ( ScenGen::st | Ord(ScenGen::st) > 1 ) do
                CurrentScenarios := ScenGen::AllScenarios;
                Scenario := first(CurrentScenarios);
                while ( Scenario ) do
                    ! body of callback to be completed by user
                    Apply( InitializeChildBranchesCallbackFunction, ScenGen::st, Scenario, ChildBranches, ChildBranchNames );
                    FirstChildBranch := first(ChildBranches);
                    break when not FirstChildBranch;
                    empty SumChildProbabilities, ScenarioProbabilityToBeAdapted;
                    ParentScenarioName := FormatString( "%e", Scenario );
                    for ( cb in ChildBranches ) do
                        if ( card(CurrentScenarios) = 1 ) then
                            ScenarioName := FormatString( "[%s", ChildBranchNames(cb) );
                        else
                            ScenarioName := FormatString( "%s,%s", ParentScenarioName, ChildBranchNames(cb) );
                        endif;
                        if ( Ord(ScenGen::st) = Card(ScenGen::AllStages) ) then
                            ScenarioName += "]";
                        endif;
                        if ( cb = FirstChildBranch ) then
                            NewScenario              := Scenario;
                            FirstScenarioProbability := ScenGen::ScenarioGenerationProbability(Scenario);
                            ChildBranchAdded := 1;
                            SetElementRename( ScenGen::AllScenarios, NewScenario, ScenarioName );
                        else
                            SetElementAdd( ScenGen::AllScenarios, NewScenario, ScenarioName );
                            for ( ScenGen::st2 | ScenGen::st2 < ScenGen::st ) do
                                Apply( InitializeNewScenarioCallbackFunction, ScenGen::st2, NewScenario, Scenario );
                            endfor;
                        endif;
                        ScenarioOrder(NewScenario) := ScenarioCount;
                        ScenarioCount += 1;
                        ScenGen::ScenarioGenerationTreeMapping(NewScenario,ScenGen::st) := NewScenario;
                        ScenGen::ScenarioGenerationTreeMapping(NewScenario,pt) := ScenGen::ScenarioGenerationTreeMapping(Scenario,pt);
                        ! body of callback to be completed by user
                        ScenGen::ScenarioGenerationProbability(NewScenario) := Apply( InitializeStochasticDataCallbackFunction, ScenGen::st, NewScenario, cb, ChildBranchNames(cb) );
                        ScenarioProbabilityToBeAdapted(NewScenario) := 1;
                        SumChildProbabilities += ScenGen::ScenarioGenerationProbability(NewScenario);
                    endfor;
                    ScenGen::ScenarioGenerationProbability( ScenGen::s | ScenarioProbabilityToBeAdapted(ScenGen::s) ) *= ( FirstScenarioProbability /$ SumChildProbabilities );
                    Scenario += 1;
                endwhile;
                if ( card(ScenGen::AllScenarios) > 1 ) then
                    ScenGen::AllScenarios := Sort( ScenGen::s, ScenarioOrder(ScenGen::s) );
                endif;
                PreviousStages += ScenGen::st;
            endfor;
            
            if ( not ChildBranchAdded ) then
                AllStochasticScenarios -= first(ScenGen::AllScenarios);
            endif;
            
            Scenarios := ScenGen::AllScenarios;
            ScenarioProbability(sosc) := ScenGen::ScenarioGenerationProbability(sosc);
            ScenarioTreeMapping(sosc,sost) := ScenGen::ScenarioGenerationTreeMapping(sosc,sost);
        }
        Set Stages {
            SubsetOf: Integers;
            Index: sost;
            Property: Input;
        }
        Set Scenarios {
            SubsetOf: AllStochasticScenarios;
            Index: sosc;
            Property: Output;
            OrderBy: user;
        }
        Parameter ScenarioProbability {
            IndexDomain: sosc;
            Property: Output;
        }
        ElementParameter ScenarioTreeMapping {
            IndexDomain: (sosc,sost);
            Range: Scenarios;
            Property: Output;
        }
        Set ChildBranches {
            SubsetOf: Integers;
            Index: cb;
        }
        StringParameter ChildBranchNames {
            IndexDomain: (cb);
        }
        ElementParameter FirstChildBranch {
            Range: Integers;
        }
        ElementParameter FirstStage {
            Range: ScenGen::AllStages;
        }
        Parameter ScenarioOrder {
            IndexDomain: (ScenGen::s);
        }
        Parameter ScenarioCount;
        ElementParameter RootScenario {
            Range: ScenGen::AllScenarios;
        }
        Set PreviousStages {
            SubsetOf: ScenGen::AllStages;
            Index: pt;
        }
        Set CurrentScenarios {
            SubsetOf: ScenGen::AllScenarios;
            OrderBy: user;
        }
        ElementParameter Scenario {
            Range: CurrentScenarios;
        }
        StringParameter ScenarioName;
        ElementParameter NewScenario {
            Range: ScenGen::AllScenarios;
        }
        StringParameter ParentScenarioName;
        Parameter FirstScenarioProbability;
        Parameter SumChildProbabilities;
        Parameter ScenarioProbabilityToBeAdapted {
            IndexDomain: (ScenGen::s);
        }
        Parameter ChildBranchAdded {
            Range: binary;
        }
    }
    Procedure MainInitialization {
        Body: {
            !This model can be built upon only in Windows environment: model development in Linux, as of 23/02/2018, is not available for academic use but it can be run on linux machine. However, Linux does not support excel file import and export.
            empty AllParameters;
            empty ALLVariables;
            
            !Choose how many min hours CCGTs should be up (default is 1 hour). This is a cumulative notation,i.e. to put min up time to 3 hours, IS_CCGT_UT_2_hours = IS_CCGT_UT_3_hours = 1 and IS_CCGT_UT_4_hours = 0
            !ATTENTION: Changing UP and DN times in input excel file is not automatically changed here, so I recommend doing in both! Also, when performing sensitivity analysis of input parameters, the programme should be closed entirely before making any changes in input the file (when asked to compile - click yes) and re-opened. This is because excel files are not automatically read.
            IS_CCGT_UT_2_hours 				:= 1;
            IS_CCGT_UT_3_hours 				:= 0;
            IS_CCGT_UT_4_hours 				:= 0;
            !Choose how many min hours CCGTs should be down (default is 1 hour)
            IS_CCGT_DT_2_hours 				:= 1;
            IS_CCGT_DT_3_hours 				:= 0;
            IS_CCGT_DT_4_hours 				:= 0;
            
            ! How many seconds each MP should run?
            lim_exec_time 					:= 500000;
            
            ! Relative optimality gap is set here only if vitali.optcr is not invoked in MainExecution 
            rel_opt_tol 					:= 0.0000; !optimality gap in percentage = rel_opt_tol * 100
            
            !Dispatch option for fuel cost: pw - piece-wise quadratic approximation; qd - quick dispatch
            !put either pwContraints and pwVariables in Mp vitali (located in declaration folder 'Declaration of Math Program') corresponding fields for piece-wise quadratic approximation or
            !qdContraints and qdVariables for quick dispatch
            
            !Carbon intensity calculated for each hour = 1 or as average of the whole period = 0
            CI_hour						:= 0;
            !CCS bypass option on - 1, off - 0
            CCS_bypass					:= 0;
            !CCS interim storage on - 1, off - 0
            CCS_interim					:= 0;
            !Are Allum-Cycle plant and its ASU coupled? Yes - 1; No - 0 
            AC_ASU_coupled 					:= 0;
            
            !Assiciate each AC plant with its ASU (mapping)
            !map_AC_to_ASU('Gas_CCS_AC_1')  := 'ASU_1'; 
            !map_AC_to_ASU('Gas_CCS_AC_2')  := 'ASU_2'; 
            !map_AC_to_ASU('Gas_CCS_AC_3')  := 'ASU_3'; 
            !map_AC_to_ASU('Gas_CCS_AC_4')  := 'ASU_4'; 
            !map_AC_to_ASU('Gas_CCS_AC_5')  := 'ASU_5'; 
            !map_AC_to_ASU('Gas_CCS_AC_6')  := 'ASU_6'; 
            !map_AC_to_ASU('Gas_CCS_AC_7')  := 'ASU_7'; 
            !map_AC_to_ASU('Gas_CCS_AC_8')  := 'ASU_8'; 
            !map_AC_to_ASU('Gas_CCS_AC_9')  := 'ASU_9'; 
            !map_AC_to_ASU('Gas_CCS_AC_10') := 'ASU_10'; 
            !map_AC_to_ASU('Gas_CCS_AC_11') := 'ASU_11'; 
            !map_AC_to_ASU('Gas_CCS_AC_12') := 'ASU_12'; 
            !map_AC_to_ASU('Gas_CCS_AC_13') := 'ASU_13'; 
            !map_AC_to_ASU('Gas_CCS_AC_14') := 'ASU_14'; 
            !map_AC_to_ASU('Gas_CCS_AC_15') := 'ASU_15'; 
            
            !Define the starting level of Oxygen tank (in 100 tonnes)
            Init_Oxy_tank_level('1') 			:= 0.25 * Oxy_tank_max_level; ! define as a proportion of the max level
            
            !Define the starting level of Energy Storage 
            !(in case of different levels for each technology, the assignment should be specified separately for 'PHS','CAES','Flywheel','Flow_Battery','Hydrogen_fuel_cell'}
            Init_storageLevel(sg,'1') 			:= 0.5 * storageLevelCap(sg); ! define as a proportion of the max level
            
            !Define the starting level of Rich Amine Storage tank
            Init_RAS_level('1') 				:= 0.25 * RAS_max_level; ! define as a proportion of the max level
            
            !optimisation options: day-by-day = 0; continuous = 1 (hard to solve for long horizons: good for shceduling for a few weeks - not sure if works properly); 
            !rolling horizon = 2 (not yet implemented); 2weekly = 3; weekly = 4
            optimis_horizon_option 				:= 0;
            
            if optimis_horizon_option=0 then
            ending_hour := 24;
            elseif optimis_horizon_option=3 then
            ending_hour := 336;
            elseif optimis_horizon_option=4 then 
            ending_hour := 168;
            endif;
            
            !Initiate starting solutions? Yes - 1, No - 0
            initial_solution 				:=0;
            
            !To run the model follow these steps in the following order:
            !1) Right-click on 'MainInitialization' 	and press 'Run Procedure'
            !2) Right-click on 'ReadFromExcel' 		and press 'Run Procedure' and wait until loaded
            !3) Right-click on 'MainExecution' 		and press 'Run Procedure' and wait for the programme to finish running
            	!Options:
            	!Press 	Ctrl+P to see the execution progress window
            	!Press  Ctrl+shift+s to terminate the programme execution
            	!Press 	Alt+F6 to debug the programme
            !4) Right-click on 'RunExternalProcedure' 	and press 'Run Procedure': outputs will be created in the designated folder
            !5) Right-click on 'MPStringExport' 	        and press 'Run Procedure': Math programme outputs will be created in the designated folder
        }
    }
    Procedure ReadFromExcel {
        Body: {
             !input parameters
             if axll::WorkBookIsOpen("capacity_data_vitali_MIP_pw.xlsx") then
             axll::SelectWorkBook("capacity_data_vitali_MIP_pw.xlsx"); 
             else
             axll::OpenWorkBook("capacity_data_vitali_MIP_pw.xlsx");
             endif;
             axll::SelectSheet("PlantData");
             axll::ReadSet(
             	SetReference:MaxGeneratorTypes,
             	SetRange:"A3:A160", 
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:plant,
             	RowHeaderRange:"A3:A160",
             	ColumnHeaderRange:"B2:BF2",
             	DataRange:"B3:BF160"); 
            
            if (optimis_horizon_option<3) then
            
            if axll::WorkBookIsOpen("demand_2010.xlsx") then
             axll::SelectWorkBook("demand_2010.xlsx");
             else
             axll::OpenWorkBook("demand_2010.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A25",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:demand,
             	RowHeaderRange:"A2:A25",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B25");
            
             !weight of each cluster
             if axll::WorkBookIsOpen("demand_2010.xlsx") then
             axll::SelectWorkBook("demand_2010.xlsx");
             else
             axll::OpenWorkBook("demand_2010.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:Years,
             	SetRange:"A27",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:weight_,
             	RowHeaderRange:"A27",
             	ColumnHeaderRange:"B26:B26",
             	DataRange:"B27:B27");
            
              !solar_LF_2010
             if axll::WorkBookIsOpen("solar_LF.xlsx") then
             axll::SelectWorkBook("solar_LF.xlsx");
             else
             axll::OpenWorkBook("solar_LF.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A25",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:solar_LF,
             	RowHeaderRange:"A2:A25",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B25");
            
             !wind_LF_2010
             if axll::WorkBookIsOpen("wind_LF.xlsx") then
             axll::SelectWorkBook("wind_LF.xlsx");
             else
             axll::OpenWorkBook("wind_LF.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A25",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:wind_LF,
             	RowHeaderRange:"A2:A25",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B25");
            
              !reserve data	
             if axll::WorkBookIsOpen("res_UP.xlsx") then
             axll::SelectWorkBook("res_UP.xlsx");
             else
             axll::OpenWorkBook("res_UP.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A25",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:res_UP,
             	RowHeaderRange:"A2:A25",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B25");
            
            elseif (optimis_horizon_option=3) then
            
            if axll::WorkBookIsOpen("demand_2010_2week.xlsx") then
             axll::SelectWorkBook("demand_2010_2week.xlsx");
             else
             axll::OpenWorkBook("demand_2010_2week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A337",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:demand,
             	RowHeaderRange:"A2:A337",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B337");
            
             !weight of each cluster
             if axll::WorkBookIsOpen("demand_2010_2week.xlsx") then
             axll::SelectWorkBook("demand_2010_2week.xlsx");
             else
             axll::OpenWorkBook("demand_2010_2week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:Years,
             	SetRange:"A339",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:weight_,
             	RowHeaderRange:"A339",
             	ColumnHeaderRange:"B338:B338",
             	DataRange:"B339:B339");
            
             !solar_LF_2010
             if axll::WorkBookIsOpen("solar_LF_2week.xlsx") then
             axll::SelectWorkBook("solar_LF_2week.xlsx");
             else
             axll::OpenWorkBook("solar_LF_2week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A337",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:solar_LF,
             	RowHeaderRange:"A2:A337",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B337");
            
             !wind_LF_2010
             if axll::WorkBookIsOpen("wind_LF_2week.xlsx") then
             axll::SelectWorkBook("wind_LF_2week.xlsx");
             else
             axll::OpenWorkBook("wind_LF_2week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A337",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:wind_LF,
             	RowHeaderRange:"A2:A337",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B337");
            
              !reserve data	
             if axll::WorkBookIsOpen("res_UP_2week.xlsx") then
             axll::SelectWorkBook("res_UP_2week.xlsx");
             else
             axll::OpenWorkBook("res_UP_2week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A337",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:res_UP,
             	RowHeaderRange:"A2:A337",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B337");
            
            elseif (optimis_horizon_option=4) then
            
            if axll::WorkBookIsOpen("demand_2010_1week.xlsx") then
             axll::SelectWorkBook("demand_2010_1week.xlsx");
             else
             axll::OpenWorkBook("demand_2010_1week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A169",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:demand,
             	RowHeaderRange:"A2:A169",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B169");
            
             !weight of each cluster
             if axll::WorkBookIsOpen("demand_2010_1week.xlsx") then
             axll::SelectWorkBook("demand_2010_1week.xlsx");
             else
             axll::OpenWorkBook("demand_2010_1week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:Years,
             	SetRange:"A171",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:weight_,
             	RowHeaderRange:"A171",
             	ColumnHeaderRange:"B170:B170",
             	DataRange:"B171:B171");
            
             !solar_LF_2010
             if axll::WorkBookIsOpen("solar_LF_1week.xlsx") then
             axll::SelectWorkBook("solar_LF_1week.xlsx");
             else
             axll::OpenWorkBook("solar_LF_1week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A169",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:solar_LF,
             	RowHeaderRange:"A2:A169",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B169");
            
             !wind_LF_2010
             if axll::WorkBookIsOpen("wind_LF_1week.xlsx") then
             axll::SelectWorkBook("wind_LF_1week.xlsx");
             else
             axll::OpenWorkBook("wind_LF_1week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A169",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:wind_LF,
             	RowHeaderRange:"A2:A169",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B169");
            
              !reserve data	
             if axll::WorkBookIsOpen("res_UP_1week.xlsx") then
             axll::SelectWorkBook("res_UP_1week.xlsx");
             else
             axll::OpenWorkBook("res_UP_1week.xlsx");
             endif;
             axll::SelectSheet("Sheet1");
             axll::ReadSet(
             	SetReference:DemandPeriods,
             	SetRange:"A2:A169",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:res_UP,
             	RowHeaderRange:"A2:A169",
             	ColumnHeaderRange:"B1:B1",
             	DataRange:"B2:B169");
            
            endif;
            
             !running_fuel_data	
             if axll::WorkBookIsOpen("Fuel spreadsheet.xlsx") then
             axll::SelectWorkBook("Fuel spreadsheet.xlsx");
             else
             axll::OpenWorkBook("Fuel spreadsheet.xlsx");
             endif;
             axll::SelectSheet("running_fuel_data");
             axll::ReadSet(
             	SetReference:MaxGeneratorTypes,
             	SetRange:"A2:A159",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:rfuel,
             	RowHeaderRange:"A2:A159",
             	ColumnHeaderRange:"B1",
             	DataRange:"B2:B159");
            
             !starting_fuel_data	
             if axll::WorkBookIsOpen("Fuel spreadsheet.xlsx") then
             axll::SelectWorkBook("Fuel spreadsheet.xlsx");
             else
             axll::OpenWorkBook("Fuel spreadsheet.xlsx");
             endif;
             axll::SelectSheet("starting_fuel_data");
             axll::ReadSet(
             	SetReference:MaxGeneratorTypes,
             	SetRange:"A2:A159",
             	ExtendSuperSets:1);
             axll::ReadTable(
             	IdentifierReference:sfuel,
             	RowHeaderRange:"A2:A159",
             	ColumnHeaderRange:"B1",
             	DataRange:"B2:B159");
            
             !initial solutions	
            if initial_solution = 1 then
            
            if axll::WorkBookIsOpen("output_base_initial.xlsx") then
             axll::SelectWorkBook("output_base_initial.xlsx");
             else
             axll::OpenWorkBook("output_base_initial.xlsx");
             endif;
             axll::SelectSheet("output_base");
             axll::ReadSet(
             	SetReference:MaxGeneratorTypes,
             	SetRange:"B1:DR1",
             	ExtendSuperSets:1);
            axll::ReadTable(
             	IdentifierReference:init_output,
             	RowHeaderRange:"A2:A169",
             	ColumnHeaderRange:"B1:DR1",
             	DataRange:"B2:DR169");
            
             if axll::WorkBookIsOpen("online_initial.xlsx") then
             axll::SelectWorkBook("online_initial.xlsx");
             else
             axll::OpenWorkBook("online_initial.xlsx");
             endif;
             axll::SelectSheet("online");
             axll::ReadSet(
             	SetReference:MaxGeneratorTypes,
             	SetRange:"B1:DR1",
             	ExtendSuperSets:1);
            axll::ReadTable(
             	IdentifierReference:init_online,
             	RowHeaderRange:"A2:A169",
             	ColumnHeaderRange:"B1:DR1",
             	DataRange:"B2:DR169");
            
             if axll::WorkBookIsOpen("starts_initial.xlsx") then
             axll::SelectWorkBook("starts_initial.xlsx");
             else
             axll::OpenWorkBook("starts_initial.xlsx");
             endif;
             axll::SelectSheet("starts");
             axll::ReadSet(
             	SetReference:MaxGeneratorTypes,
             	SetRange:"B1:DR1",
             	ExtendSuperSets:1);
            axll::ReadTable(
             	IdentifierReference:init_starts,
             	RowHeaderRange:"A2:A169",
             	ColumnHeaderRange:"B1:DR1",
             	DataRange:"B2:DR169");
            
             if axll::WorkBookIsOpen("stops_initial.xlsx") then
             axll::SelectWorkBook("stops_initial.xlsx");
             else
             axll::OpenWorkBook("stops_initial.xlsx");
             endif;
             axll::SelectSheet("stops");
             axll::ReadSet(
             	SetReference:MaxGeneratorTypes,
             	SetRange:"B1:DR1",
             	ExtendSuperSets:1);
            axll::ReadTable(
             	IdentifierReference:init_stops,
             	RowHeaderRange:"A2:A169",
             	ColumnHeaderRange:"B1:DR1",
             	DataRange:"B2:DR169");
            endif;
        }
        Comment: {
            "This could go first in Main Execution if reading from excel is done here instead exercising the external procedure!
            !    Block ! Execution 1.
            !        !Title  Profit-Store2 Model; Author: Vitali Avagyan 
            !    EndBlock ;
            !    ExcelRetrieveTable(
            !	ExcelWorkbook           :  \'capacity_data_vitali_low_test_MIP.xlsx\',   
            !	Parameter               :  plant, 
            !	DataRange               :  \'B4:S82\',  
            !	RowsRange               :  \'A4:A82\',     
            !	ColumnsRange            :  \'B3:S3\',  
            !	Sheet                   :  \'PlantData\', 
            !	AutomaticallyExtendSets :  0);
            
            !ExcelRetrieveTable(
            !	ExcelWorkbook           :  \'net_demand_2010.xlsx\',  
            !	Parameter               :  demand, 
            !	DataRange               :  \'B2:NB25\',  
            !	RowsRange               :  \'A2:A25\', 
            !	ColumnsRange            :  \'B1:NB1\',  
            !	Sheet                   :  \'Sheet1\',  
            !	AutomaticallyExtendSets :  0);	
            !ExcelRetrieveTable(
            !	ExcelWorkbook           :  \'net_demand_2010.xlsx\',  
            !	Parameter               :   weight_, 
            !	DataRange               :  \'B27:NB27\',  
            !	RowsRange               :  \'A27\',  
            !	ColumnsRange            :  \'B26:NB26\',  
            !	Sheet                   :  \'Sheet1\',  
            !	AutomaticallyExtendSets :  0);	
            
            !ExcelRetrieveTable(
            !	ExcelWorkbook           :  \'Fuel spreadsheet.xlsx\', 
            !	Parameter               :   rfuel, 
            !	DataRange               :  \'B2:B69\', 
            !	RowsRange               :  \'A2:A69\',  
            !	ColumnsRange            :  \'B1\',  
            !	Sheet                   :  \'running_fuel_data\', 
            !	AutomaticallyExtendSets :  0);
            !ExcelRetrieveTable(
            !	ExcelWorkbook           :  \'Fuel spreadsheet.xlsx\', 
            !	Parameter               :   sfuel, 
            !	DataRange               :  \'B2:B69\',  
            !	RowsRange               :  \'A2:A69\',  
            !	ColumnsRange            :  \'B1\',   
            !	Sheet                   :  \'starting_fuel_data\', 
            !	AutomaticallyExtendSets :  0);
            !ExcelRetrieveTable(
            !	ExcelWorkbook           :  \'res_UP.xlsx\',     
            !	Parameter               :  res_UP,   
            !	DataRange               :  \'B2:NB25\',  
            !	RowsRange               :  \'A2:A25\', 
            !	ColumnsRange            :  \'B1:NB1\',  
            !	Sheet                   :  \'Sheet1\',  
            !	AutomaticallyExtendSets :  0);"
        }
    }
    Procedure StochasticProcedures {
        Body: {
            !Begin Stochastic block
            DemandPeriodToStageMapping('1',t)  := 1;
            DemandPeriodToStageMapping('2',t)  := 2;
            
            CommitmentStage(t) := DemandPeriodToStageMapping('1',t);
            DispatchStage(t)   := DemandPeriodToStageMapping('2',t);
            
            empty AllStochasticScenarios;
            cleandependents AllStochasticScenarios;
            
            
            InitializeNewScenarioCallbackFunction:='InitializeNewScenarioCallback';
            InitializeStochasticDataCallbackFunction:='InitializeStochasticDataCallback';
            InitializeChildBranchesCallbackFunction:='InitializeChildBranchesCallback';
            
            CreateScenarioTree(Stages,Scenarios,ScenarioProbability,ScenarioTreeMapping );
            !End Stochastic block
        }
    }
    Procedure SolveStochasticUC {
        Body: {
            Block ! Main body of execution.
            for (f) do !fuel-price loop
                                DemandProfiles_dynamic(d) :=no;
                                 for (d) do ! cluster loop
                                  DemandProfiles_dynamic(d) :=yes;
            
                                  for (l) do !iteration loop
            	MyStochasticUCGMP := GMP::Instance::GenerateStochasticProgram(
            				vitali,
            				AllStochasticParameters,
            				AllStochasticVariables,
            				Scenarios,
            				ScenarioProbability,
            				ScenarioTreeMapping,
            				"DeterministicUC",
            				GenerationMode:'CreateNonAnticipativityConstraints', ! Alternatives: 'CreateNonAnticipativityConstraints', 'SubstituteStochasticVariables'
            				name:"StochasticUC" );
            
            	GMP::Instance::Solve(MyStochasticUCGMP);
            
             Online_end_1(g,d+1)		:=Online.Level(g,'23',d);
             Online_end(g,d+1)		:=Online.Level(g,'24',d);
             Online_end_2(g,d+1)		:=Online.Level(g,'22',d);
             Online_end_3(g,d+1)		:=Online.Level(g,'21',d);
             Output_end(g,d+1)     		:=output_.Level(g,'24',d);
               endfor; ! end of l loop
                   	DemandProfiles_dynamic(d) :=no;
              endfor ;! end of d loop
            endfor ;! end of f loop
            endblock;
        }
    }
    Procedure RunStochasticResults {
        Body: {
            o5_Stoch_onlineResults(sc,f,g,t,d,l) 	:= Online.Stochastic(sc,g,t,d); 
            o5_Stoch_outputResults(sc,f,g,t,d,l) 	:= output_.Stochastic(sc,g,t,d); 
            o5_Stoch_totalCost(sc) 			:= totalCost.Stochastic(sc);
            o5_Stoch_demand(sc,t,d) 		:= demand.Stochastic(sc,t,d);
            o5_Stoch_solar_LF(sc,t,d) 		:= solar_LF.Stochastic(sc,t,d);
            o5_Stoch_wind_LF(sc,t,d) 		:= wind_LF.Stochastic(sc,t,d);
        }
    }
    Procedure MainExecution {
        Body: {
            !demand(sc,t,d).Stochastic :=Uniform(20,62);
            
            Block ! Preliminary calculation.
                                ! convert from MW to GW if necessary..
                                if (demandScale <> 1) then demand(t,d) 		:=demand(t,d) / demandScale; 
                                endif ;
                        !Calculate min inertia floor here instead of importing from pre-calculated levels from excel!
                        !         plant('PHS', 'maxPower') 				:=StorageCap('PHS');
                        !         plant('CAES', 'maxPower') 			:=StorageCap('CAES');
                        !         plant('Flywheel', 'maxPower') 			:=StorageCap('Flywheel');
                        !         plant('Flow_Battery', 'maxPower') 		:=StorageCap('Flow_Battery');
                        !         plant('Hydrogen_Fuel_Cell', 'maxPower')		:=StorageCap('Hydrogen_Fuel_Cell');
            
            !Initial solutions can be passed at the beginning of the optimisation
            output_(g,t,d)				:=init_output(t,g);
            Online(g,t,d)				:=init_online(t,g);
            Started(g,t,d)				:=init_starts(t,g);
            Stopped(g,t,d)				:=init_stops(t,g);
            EndBlock ;
            
            Block ! Initialising storage.
                                ! limit the storage level to be between 0 and the capacity limit
            !                     storageLevel.Lower(sg,t,d) := 0;
            !                     storageLevel.Upper(sg,t,d) := storageLevelCap(sg);
            !                     storageInput.Lower(sg,t,d) := 0;
            !                     storageInput.Upper(sg,t,d) := plant(sg,'numPlant')*plant(sg,'maxPower');
            EndBlock ;
            
            Block ! Optimality criteria. 
                                !vitali.optcr :=0.00;
                                !CCS_profit.optcr :=0.00;
                        !        vitali.CallbackAOA			:='OuterApprox::BasicAlgorithm';
                        !        OuterApprox::IterationMax 		:= 1; 
                        !        myGMP 				:= GMP::Instance::Generate(vitali);
                        !
                        !	GMPOuterApprox::IterationMax 		:= 1;
                        !	GMPOuterApprox::DoOuterApproximation(myGMP);
                        !	GMPOuterApprox::CreateStatusFile 	:= 1;
                            EndBlock ;
            
            Block ! Main body of execution.
            for (f) do !fuel-price loop
                        !          for (d) do
                        		if (optimis_horizon_option=0) then
                        	! we loop over our clustered days, setting each element of dd to yes in turn
                        	 ! so that all of the above equations focus on one day at a time...
            
                                DemandProfiles_dynamic(d) :=no;
                                 for (d) do ! cluster loop
                                  DemandProfiles_dynamic(d) :=yes;
            
                                  for (l) do !iteration loop
            
            !                    	r_for_calculation(ccs,t,d)				:= r_p_iteration(ccs,t,d,l);
            !            		RAS_discharge_for_calculation(ccs,t,d)			:= RAS_discharge_p_iteration(ccs,t,d);
            !            		RAS_charge_r_for_calculation(ccs,t,d)			:= RAS_charge_r_p_iteration(ccs,t,d);
            !            		bypass_for_calculation(ccs,t,d)				:= bypass_p_iteration(ccs,t,d);
            !
            !            		productionTh_for_calculation(ccs,t,d) 			:= productionTh_p_iteration(ccs,t,d,l);
            !            		k_CCS_for_calculation(ccs,t,d)				:= k_CCS_p_iteration(ccs,t,d,l);
            !
            !            penalty_CCS(ccs,t,d) := 
            !            alpha * RAS_discharge_for_calculation(ccs,t,d) * k_CCS_for_calculation(ccs,t,d) * plant(ccs,'CC_FIXED')/1000 + !CCS penalty
            !            !(plant(ccs,'CC_OP')/1000) * RAS_discharge_productionTh_for_calculation(ccs,t,d) * plant(ccs,'CO2') * 1000 * r_for_calculation(ccs,t,d) +
            !             plant(ccs,'CC_OP')/1000  * productionTh_for_calculation(ccs,t,d) 		* plant(ccs,'CO2') * 1000 * r_for_calculation(ccs,t,d) +
            !            !	RAS_charge_k_CCS_for_calculation(ccs,t,d)    * plant(ccs,'CC_FIXED')/1000 -
            !            (plant(ccs,'CC_OP')/1000) * productionTh_for_calculation(ccs,t,d)    * plant(ccs,'CO2') * 1000 * RAS_charge_r_for_calculation(ccs,t,d) + 
            !            k_CCS_for_calculation(ccs,t,d)        				* Fixed_Capture_Penalty/1000 - 
            !            bypass_for_calculation(ccs,t,d) * k_CCS_for_calculation(ccs,t,d) * Fixed_Capture_Penalty/1000 +
            !            k_CCS_for_calculation(ccs,t,d) 		 	     * plant(ccs,'CC_FIXED')/1000;
            !
                                   Solve vitali where MIP_Relative_Optimality_Tolerance :=rel_opt_tol, time_limit := lim_exec_time; ! activate this if it is set manually in MainInitialization
            
                                   Online_end_1(g,d+1)		:=Online.Level(g,'23',d);
                                   Online_end(g,d+1)		:=Online.Level(g,'24',d);
                                   Online_end_2(g,d+1)		:=Online.Level(g,'22',d);
                                   Online_end_3(g,d+1)		:=Online.Level(g,'21',d);
                                   Output_end(g,d+1)     		:=output_.Level(g,'24',d);
            
                                ! integer shadow prices for meeting just demand
                                  o5_D_marginals(f,t,d,l) 				:= eqDemandMet.ShadowPrice(t,d)/1000 ; ! to make it /MWh
                                ! shadow prices for energy plus reserve = electricity price
                                  o5_D_S_marginals(f,t,d,l) 			:= (eqDemandMet.ShadowPrice(t,d) + eqSpinningMet.ShadowPrice(t,d))/1000 ;! to make it /MWh
                                  lambda(t,d) 					:= o5_D_S_marginals(f,t,d,l);
                                  o5_costResults(f,d,l)				:= totalCost.Level;
                                  o5_outputResults_base(f,g,t,d,l)			:= output_.Level(g,t,d);
                                  o5_outputResults_net(f,g,t,d,l)			:= output_.Level(g,t,d);                      
                                  o5_outputResults_net(f,pccs,t,d,l)		:= output_.Level(pccs,t,d) - Penalty_PCCS.Level(pccs,t,d);
                                  o5_outputResults_net(f,ac,t,d,l)			:= output_.Level(ac,t,d) - Penalty_AC_positive.Level(ac,t,d) + Penalty_AC_negative.Level(ac,t,d);
                                  o5_outputResults_net(f,sg,t,d,l)			:= output_.Level(sg,t,d) * storageDischargeEff(sg) - storageInput.Level(sg,t,d);
                                  o5_Capacity_StartedResults(f,g,t,d,l)		:= Started.Level(g,t,d);
                                  o5_Capacity_StoppedResults(f,g,t,d,l)		:= Stopped.Level(g,t,d);
                                  o5_Capacity_OnlineResults(f,g,t,d,l)		:= Online.Level(g,t,d);
                                  !o5_dailyCostResults(f,d)				:= dailyCost.Level(d);
                                  o5_storageInputResults(f,sg,t,d,l)		:= storageInput.Level(sg,t,d);
                                  o5_storageLevelResults(f,sg,t,d,l)		:= storageLevel.Level(sg,t,d);
                                  o5_eqMinLimit(f,g,t,d,l)				:= eqMinLimit.ShadowPrice(g,t,d);
                                  o5_eqMaxLimit(f,g,t,d,l)				:= eqMaxLimit.ShadowPrice(g,t,d);
                                  o5_eqDiffUPRamp(f,g,t,d,l)			:= eqDiffUPRamp.ShadowPrice(g,t,d);
                                  o5_eqDiffUPRamp_initial(f,g,d,l)			:= eqDiffUPRamp_initial.ShadowPrice(g,d);
                                  o5_eqDiffDNRamp(f,g,t,d,l)			:= eqDiffDNRamp.ShadowPrice(g,t,d);
                                  o5_eqDiffDNRamp_initial(f,g,d,l)			:= eqDiffDNRamp_initial.ShadowPrice(g,d);
                                  o5_eqRampUP(f,g,t,d,l)				:= eqRampUP.ShadowPrice(g,t,d);
                                  o5_eqRampDN(f,g,t,d,l)				:= eqRampDN.ShadowPrice(g,t,d);
                                  o5_reserve_UP(f,drg,t,d,l)			:= Online.Level(drg,t,d) * plant(drg, 'MaxPower') - output_.Level(drg,t,d);
                                  o5_reserve_UP(f,sg,t,d,l)				:= storageDischargeEff(sg) * (sg_Online_availLevel.Level(sg,t,d) - output_.Level(sg,t,d));
            		      o5_carbon_intensity_hour(f,t,d)			:= 1000 * (sum(nccs, 1000 * output_.Level(nccs,t,d) * plant(nccs,'CO2') * 1/plant(nccs,'GINC')) + sum(ccs, 1000 * output_.Level(ccs,t,d) * plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT')))) / (sum(nccs, 1000 * output_.Level(nccs,t,d)) + sum(ccs, 1000 * output_.Level(ccs,t,d)));
            		      o5_Status_DT(f,g,t,d,l)				:= Status_DT.Level(g,t,d);
            
                        	      o5_penalty_level(f,pccs,t,d,l)			:= penalty_CCS(pccs,t,d);
            
                                  o5_heat_continuation(f,d,t,ac,l)				:= heat_continuation.Level(ac,t,d);
                                  o5_charging(f,d,t,sg,l)				:= charging.Level(sg,t,d);
                                  o5_discharging(f,d,t,sg,l)			:= discharging.Level(sg,t,d);
                                  o5_Penalty_AC(f,d,t,ac,l)				:= Penalty_AC_positive.Level(ac,t,d) + Penalty_AC_negative.Level(ac,t,d);
                                  o5_Oxy_tank_level(f,d,t,ac,l)			:= Oxy_tank_level.Level(ac,t,d);
                                  o5_tank_leakage(f,d,t,ac,l)			:= tank_leakage(ac,t,d);
                                  o5_Penalty_PCCS(f,d,t,pccs,l)			:= Penalty_PCCS.Level(pccs,t,d);
            
            
            
            !            	  output_c_iteration(ccs,t,d) 					:= output_.Level(ccs,t,d);
            !            	  productionTh_c_iteration(ccs,t,d)				:= productionTh.Level(ccs,t,d);
            !            	  price_c_iteration(t,d)					:= o5_D_S_marginals(f,t,d,l);
            !            	  k_CCS_c_iteration(ccs,t,d)					:= k_CCS.Level(ccs,t,d);
            !
            !            	   Solve CCS_profit;
            !                   r_p_iteration(ccs,t,d,l+1)					:= r_.Level(ccs,t,d);
            !            	   RAS_discharge_p_iteration(ccs,t,d)				:= RAS_discharge.Level(ccs,t,d);
            !            	   RAS_charge_r_p_iteration(ccs,t,d)				:= RAS_charge_r.Level(ccs,t,d);
            !            	   bypass_p_iteration(ccs,t,d)					:= bypass_.Level(ccs,t,d);
            !
            !            	   productionTh_p_iteration(ccs,t,d,l+1)			:= productionTh_c_iteration(ccs,t,d);
            !            	   k_CCS_p_iteration(ccs,t,d,l+1)				:= k_CCS_c_iteration(ccs,t,d);
            !
            !            	   o5_r(ccs,t,d,l)						:= r_.Level(ccs,t,d);
            !            	   o5_RAS_level(f,ccs,t,d,l) 					:= RAS_level.Level(ccs,t,d);
            !                   o5_RAS_charge(f,ccs,t,d,l) 					:= RAS_charge.Level(ccs,t,d);
            !                   o5_RAS_discharge(f,ccs,t,d,l) 				:= RAS_discharge.Level(ccs,t,d);
            !            	   o5_bypass(f,ccs,t,d,l) 				  	:= bypass_.Level(ccs,t,d);
            
                        	  endfor; ! end of the l loop
            
                        	DemandProfiles_dynamic(d) :=no;
            
                                  endfor ;! end of the d loop
            
                                  elseif (optimis_horizon_option=1) then
            
                                  DemandProfiles_dynamic(d) :=yes;
                                 !for (d) do
                                  !DemandProfiles_dynamic(d) :=yes;
            
                                  for (l) do
            
                                    r_for_calculation(pccs,t,d) 				:= r_p_iteration(pccs,t,d,l);
                        		RAS_discharge_for_calculation(pccs,t,d)			:= RAS_discharge_p_iteration(pccs,t,d);
                        		RAS_charge_r_for_calculation(pccs,t,d)			:= RAS_charge_r_p_iteration(pccs,t,d);
                        		bypass_for_calculation(pccs,t,d)			:= bypass_p_iteration(pccs,t,d);
            
                        		productionTh_for_calculation(pccs,t,d) 			:= productionTh_p_iteration(pccs,t,d,l);
                        		k_CCS_for_calculation(pccs,t,d)				:= k_CCS_p_iteration(pccs,t,d,l);
            
                        penalty_CCS(pccs,t,d) := 
                        alpha * RAS_discharge_for_calculation(pccs,t,d) * k_CCS_for_calculation(pccs,t,d) * plant(pccs,'CC_FIXED')/1000 + !CCS penalty
                        !(plant(ccs,'CC_OP')/1000) * RAS_discharge_productionTh_for_calculation(ccs,t,d) * plant(ccs,'CO2') * 1000 * r_for_calculation(ccs,t,d) +
                         plant(pccs,'CC_OP')/1000  * productionTh_for_calculation(pccs,t,d) 		* plant(pccs,'CO2') * 1000 * r_for_calculation(pccs,t,d) +
                        !	RAS_charge_k_CCS_for_calculation(ccs,t,d)    * plant(ccs,'CC_FIXED')/1000 -
                        (plant(pccs,'CC_OP')/1000) * productionTh_for_calculation(pccs,t,d)    * plant(pccs,'CO2') * 1000 * RAS_charge_r_for_calculation(pccs,t,d) + 
                        k_CCS_for_calculation(pccs,t,d)        				* Fixed_Capture_Penalty/1000 - 
                        bypass_for_calculation(pccs,t,d) * k_CCS_for_calculation(pccs,t,d) * Fixed_Capture_Penalty/1000 +
                        k_CCS_for_calculation(pccs,t,d) 		 	     * plant(pccs,'CC_FIXED')/1000;
            
                                   Solve vitali where MIP_Relative_Optimality_Tolerance :=rel_opt_tol, time_limit := lim_exec_time; ! activate this if it is set manually in MainInitialization
            
                                   Online_end_1(g,d+1)		:=Online.Level(g,'23',d);
                                   Online_end(g,d+1)		:=Online.Level(g,'24',d);
                                   Online_end_2(g,d+1)		:=Online.Level(g,'22',d);
                                   Online_end_3(g,d+1)		:=Online.Level(g,'21',d);
                                   Output_end(g,d+1)     		:=output_.Level(g,'24',d);
            
                                ! integer shadow prices for meeting just demand
                                  o5_D_marginals(f,t,d,l) 				:= eqDemandMet.ShadowPrice(t,d)/1000 ; ! to make it /MW
                                ! shadow prices for energy plus reserve = electricity price
                                  o5_D_S_marginals(f,t,d,l) 			:= (eqDemandMet.ShadowPrice(t,d) + eqSpinningMet.ShadowPrice(t,d))/1000 ;! to make it /MW
                                  lambda(t,d) 					:= o5_D_S_marginals(f,t,d,l);
                                  o5_costResults(f,d,l)				:= totalCost.Level;
                                  o5_outputResults_base(f,g,t,d,l)			:= output_.Level(g,t,d);
                                  o5_outputResults_net(f,g,t,d,l)			:= output_.Level(g,t,d);                                           
                                  o5_outputResults_net(f,pccs,t,d,l)		:= output_.Level(pccs,t,d) - Penalty_PCCS.Level(pccs,t,d);
                                  o5_outputResults_net(f,ac,t,d,l)			:= output_.Level(ac,t,d) - Penalty_AC_positive.Level(ac,t,d) + Penalty_AC_negative.Level(ac,t,d);
                                  o5_outputResults_net(f,sg,t,d,l)			:= output_.Level(sg,t,d) * storageDischargeEff(sg) - storageInput.Level(sg,t,d);
                                  o5_Capacity_StartedResults(f,g,t,d,l)		:= Started.Level(g,t,d);
                                  o5_Capacity_StoppedResults(f,g,t,d,l)		:= Stopped.Level(g,t,d);
                                  o5_Capacity_OnlineResults(f,g,t,d,l)		:= Online.Level(g,t,d);
                                  !o5_dailyCostResults(f,d)				:= dailyCost.Level(d);
                                  o5_storageInputResults(f,sg,t,d,l)		:= storageInput.Level(sg,t,d);
                                  o5_storageLevelResults(f,sg,t,d,l)		:= storageLevel.Level(sg,t,d);
                                  o5_eqMinLimit(f,g,t,d,l)				:= eqMinLimit.ShadowPrice(g,t,d);
                                  o5_eqMaxLimit(f,g,t,d,l)				:= eqMaxLimit.ShadowPrice(g,t,d);
                                  o5_eqDiffUPRamp(f,g,t,d,l)			:= eqDiffUPRamp.ShadowPrice(g,t,d);
                                  o5_eqDiffUPRamp_initial(f,g,d,l)			:= eqDiffUPRamp_initial.ShadowPrice(g,d);
                                  o5_eqDiffDNRamp(f,g,t,d,l)			:= eqDiffDNRamp.ShadowPrice(g,t,d);
                                  o5_eqDiffDNRamp_initial(f,g,d,l)			:= eqDiffDNRamp_initial.ShadowPrice(g,d);
                                  o5_eqRampUP(f,g,t,d,l)				:= eqRampUP.ShadowPrice(g,t,d);
                                  o5_eqRampDN(f,g,t,d,l)				:= eqRampDN.ShadowPrice(g,t,d);
                                  o5_reserve_UP(f,drg,t,d,l)			:= Online.Level(drg,t,d) * plant(drg, 'MaxPower') - output_.Level(drg,t,d);
                                  o5_reserve_UP(f,sg,t,d,l)				:= storageDischargeEff(sg) * (sg_Online_availLevel.Level(sg,t,d) - output_.Level(sg,t,d));
            		      o5_carbon_intensity_hour(f,t,d)			:= 1000 * (sum(nccs, 1000 * output_.Level(nccs,t,d) * plant(nccs,'CO2') * 1/plant(nccs,'GINC')) + sum(ccs, 1000 * output_.Level(ccs,t,d) * plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT')))) / (sum(nccs, 1000 * output_.Level(nccs,t,d)) + sum(ccs, 1000 * output_.Level(ccs,t,d)));
            		      o5_Status_DT(f,g,t,d,l)				:= Status_DT.Level(g,t,d);
            
            		      o5_penalty_level(f,pccs,t,d,l)			:= penalty_CCS(pccs,t,d);
            
                                  o5_heat_continuation(f,d,t,ac,l)				:= heat_continuation.Level(ac,t,d);
                                  o5_charging(f,d,t,sg,l)				:= charging.Level(sg,t,d);
                                  o5_discharging(f,d,t,sg,l)			:= discharging.Level(sg,t,d);
                                  o5_Penalty_AC(f,d,t,ac,l)				:= Penalty_AC_positive.Level(ac,t,d) + Penalty_AC_negative.Level(ac,t,d);
                                  o5_Oxy_tank_level(f,d,t,ac,l)			:= Oxy_tank_level.Level(ac,t,d);
                                  o5_tank_leakage(f,d,t,ac,l)			:= tank_leakage(ac,t,d);
                                  o5_Penalty_PCCS(f,d,t,pccs,l)			:= Penalty_PCCS.Level(pccs,t,d);
            
            
            
                        	      output_c_iteration(pccs,t,d) 			:= output_.Level(pccs,t,d);
                        	      productionTh_c_iteration(pccs,t,d)		:= productionTh.Level(pccs,t,d);
                        	      price_c_iteration(t,d)				:= o5_D_S_marginals(f,t,d,l);
                        	      k_CCS_c_iteration(pccs,t,d)			:= k_CCS.Level(pccs,t,d);
            
                                   Solve CCS_profit;
                                  r_p_iteration(pccs,t,d,l+1)			:= r_.Level(pccs,t,d);
                        	      RAS_discharge_p_iteration(pccs,t,d)		:= RAS_discharge.Level(pccs,t,d);
                        	      RAS_charge_r_p_iteration(pccs,t,d)			:= RAS_charge_r.Level(pccs,t,d);
                        	      bypass_p_iteration(pccs,t,d)			:= bypass_.Level(pccs,t,d);
            
                        	      productionTh_p_iteration(pccs,t,d,l+1)		:= productionTh_c_iteration(pccs,t,d);
                        	      k_CCS_p_iteration(pccs,t,d,l+1)			:= k_CCS_c_iteration(pccs,t,d);
            
                        	      o5_r(pccs,t,d,l)					:= r_.Level(pccs,t,d);
                        	      o5_RAS_level(f,pccs,t,d,l) 			:= RAS_level.Level(pccs,t,d);
                                  o5_RAS_charge(f,pccs,t,d,l) 			:= RAS_charge.Level(pccs,t,d);
                                  o5_RAS_discharge(f,pccs,t,d,l) 			:= RAS_discharge.Level(pccs,t,d);
                        	      o5_bypass(f,pccs,t,d,l) 				:= bypass_.Level(pccs,t,d);
            
                        	  endfor; ! end of the l loop
            
                        	!DemandProfiles_dynamic(d) :=no;
            
                                  !endfor ;! end of the d loop
            
                                  elseif (optimis_horizon_option=3) then
                        	! we loop over our clustered days, setting each element of dd to yes in turn
                        	 ! so that all of the above equations focus on one day at a time...
            
                                DemandProfiles_dynamic(d) :=no;
                                 for (d) do ! cluster loop
                                  DemandProfiles_dynamic(d) :=yes;
            
                                  for (l) do !iteration loop
            
            !                    	r_for_calculation(ccs,t,d)				:= r_p_iteration(ccs,t,d,l);
            !            		RAS_discharge_for_calculation(ccs,t,d)			:= RAS_discharge_p_iteration(ccs,t,d);
            !            		RAS_charge_r_for_calculation(ccs,t,d)			:= RAS_charge_r_p_iteration(ccs,t,d);
            !            		bypass_for_calculation(ccs,t,d)				:= bypass_p_iteration(ccs,t,d);
            !
            !            		productionTh_for_calculation(ccs,t,d) 			:= productionTh_p_iteration(ccs,t,d,l);
            !            		k_CCS_for_calculation(ccs,t,d)				:= k_CCS_p_iteration(ccs,t,d,l);
            !
            !            penalty_CCS(ccs,t,d) := 
            !            alpha * RAS_discharge_for_calculation(ccs,t,d) * k_CCS_for_calculation(ccs,t,d) * plant(ccs,'CC_FIXED')/1000 + !CCS penalty
            !            !(plant(ccs,'CC_OP')/1000) * RAS_discharge_productionTh_for_calculation(ccs,t,d) * plant(ccs,'CO2') * 1000 * r_for_calculation(ccs,t,d) +
            !             plant(ccs,'CC_OP')/1000  * productionTh_for_calculation(ccs,t,d) 		* plant(ccs,'CO2') * 1000 * r_for_calculation(ccs,t,d) +
            !            !	RAS_charge_k_CCS_for_calculation(ccs,t,d)    * plant(ccs,'CC_FIXED')/1000 -
            !            (plant(ccs,'CC_OP')/1000) * productionTh_for_calculation(ccs,t,d)    * plant(ccs,'CO2') * 1000 * RAS_charge_r_for_calculation(ccs,t,d) + 
            !            k_CCS_for_calculation(ccs,t,d)        				* Fixed_Capture_Penalty/1000 - 
            !            bypass_for_calculation(ccs,t,d) * k_CCS_for_calculation(ccs,t,d) * Fixed_Capture_Penalty/1000 +
            !            k_CCS_for_calculation(ccs,t,d) 		 	     * plant(ccs,'CC_FIXED')/1000;
            !
                                   Solve vitali where MIP_Relative_Optimality_Tolerance :=rel_opt_tol, time_limit := lim_exec_time; ! activate this if it is set manually in MainInitialization
            
                                   Online_end_1(g,d+1)		:=Online.Level(g,'335',d);
                                   Online_end(g,d+1)		:=Online.Level(g,'336',d);
                                   Online_end_2(g,d+1)		:=Online.Level(g,'334',d);
                                   Online_end_3(g,d+1)		:=Online.Level(g,'333',d);
                                   Output_end(g,d+1)     		:=output_.Level(g,'336',d);
            
                                ! integer shadow prices for meeting just demand
                                  o5_D_marginals(f,t,d,l) 				:= eqDemandMet.ShadowPrice(t,d)/1000 ; ! to make it /MWh
                                ! shadow prices for energy plus reserve = electricity price
                                  o5_D_S_marginals(f,t,d,l) 			:= (eqDemandMet.ShadowPrice(t,d) + eqSpinningMet.ShadowPrice(t,d))/1000 ;! to make it /MWh
                                  lambda(t,d) 					:= o5_D_S_marginals(f,t,d,l);
                                  o5_costResults(f,d,l)				:= totalCost.Level;
                                  o5_outputResults_base(f,g,t,d,l)			:= output_.Level(g,t,d);
                                  o5_outputResults_net(f,g,t,d,l)			:= output_.Level(g,t,d);                                            
                                  o5_outputResults_net(f,pccs,t,d,l)		:= output_.Level(pccs,t,d) - Penalty_PCCS.Level(pccs,t,d);
                                  o5_outputResults_net(f,ac,t,d,l)			:= output_.Level(ac,t,d) - Penalty_AC_positive.Level(ac,t,d) + Penalty_AC_negative.Level(ac,t,d);
                                  o5_outputResults_net(f,sg,t,d,l)			:= output_.Level(sg,t,d) * storageDischargeEff(sg) - storageInput.Level(sg,t,d);
                                  o5_Capacity_StartedResults(f,g,t,d,l)		:= Started.Level(g,t,d);
                                  o5_Capacity_StoppedResults(f,g,t,d,l)		:= Stopped.Level(g,t,d);
                                  o5_Capacity_OnlineResults(f,g,t,d,l)		:= Online.Level(g,t,d);
                                  !o5_dailyCostResults(f,d)				:= dailyCost.Level(d);
                                  o5_storageInputResults(f,sg,t,d,l)		:= storageInput.Level(sg,t,d);
                                  o5_storageLevelResults(f,sg,t,d,l)		:= storageLevel.Level(sg,t,d);
                                  o5_eqMinLimit(f,g,t,d,l)				:= eqMinLimit.ShadowPrice(g,t,d);
                                  o5_eqMaxLimit(f,g,t,d,l)				:= eqMaxLimit.ShadowPrice(g,t,d);
                                  o5_eqDiffUPRamp(f,g,t,d,l)			:= eqDiffUPRamp.ShadowPrice(g,t,d);
                                  o5_eqDiffUPRamp_initial(f,g,d,l)			:= eqDiffUPRamp_initial.ShadowPrice(g,d);
                                  o5_eqDiffDNRamp(f,g,t,d,l)			:= eqDiffDNRamp.ShadowPrice(g,t,d);
                                  o5_eqDiffDNRamp_initial(f,g,d,l)			:= eqDiffDNRamp_initial.ShadowPrice(g,d);
                                  o5_eqRampUP(f,g,t,d,l)				:= eqRampUP.ShadowPrice(g,t,d);
                                  o5_eqRampDN(f,g,t,d,l)				:= eqRampDN.ShadowPrice(g,t,d);
                                  o5_reserve_UP(f,drg,t,d,l)			:= Online.Level(drg,t,d) * plant(drg, 'MaxPower') - output_.Level(drg,t,d);
                                  o5_reserve_UP(f,sg,t,d,l)				:= storageDischargeEff(sg) * (sg_Online_availLevel.Level(sg,t,d) - output_.Level(sg,t,d));
            		      o5_carbon_intensity_hour(f,t,d)			:= 1000 * (sum(nccs, 1000 * output_.Level(nccs,t,d) * plant(nccs,'CO2') * 1/plant(nccs,'GINC')) + sum(ccs, 1000 * output_.Level(ccs,t,d) * plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT')))) / (sum(nccs, 1000 * output_.Level(nccs,t,d)) + sum(ccs, 1000 * output_.Level(ccs,t,d)));
            		      o5_Status_DT(f,g,t,d,l)				:= Status_DT.Level(g,t,d);
            
                        	      o5_penalty_level(f,pccs,t,d,l)			:= penalty_CCS(pccs,t,d);
            
            		      o5_heat_continuation(f,d,t,ac,l)			:= heat_continuation.Level(ac,t,d);
                                  o5_charging(f,d,t,sg,l)				:= charging.Level(sg,t,d);
                                  o5_discharging(f,d,t,sg,l)			:= discharging.Level(sg,t,d);
                                  o5_Penalty_AC(f,d,t,ac,l)				:= Penalty_AC_positive.Level(ac,t,d) + Penalty_AC_negative.Level(ac,t,d);
                                  o5_Oxy_tank_level(f,d,t,ac,l)			:= Oxy_tank_level.Level(ac,t,d);
                                  o5_tank_leakage(f,d,t,ac,l)			:= tank_leakage(ac,t,d);
                                  o5_Penalty_PCCS(f,d,t,pccs,l)			:= Penalty_PCCS.Level(pccs,t,d);
            
            
            
            !            	  output_c_iteration(ccs,t,d) 					:= output_.Level(ccs,t,d);
            !            	  productionTh_c_iteration(ccs,t,d)				:= productionTh.Level(ccs,t,d);
            !            	  price_c_iteration(t,d)					:= o5_D_S_marginals(f,t,d,l);
            !            	  k_CCS_c_iteration(ccs,t,d)					:= k_CCS.Level(ccs,t,d);
            !
            !            	   Solve CCS_profit;
            !                   r_p_iteration(ccs,t,d,l+1)					:= r_.Level(ccs,t,d);
            !            	   RAS_discharge_p_iteration(ccs,t,d)				:= RAS_discharge.Level(ccs,t,d);
            !            	   RAS_charge_r_p_iteration(ccs,t,d)				:= RAS_charge_r.Level(ccs,t,d);
            !            	   bypass_p_iteration(ccs,t,d)					:= bypass_.Level(ccs,t,d);
            !
            !            	   productionTh_p_iteration(ccs,t,d,l+1)			:= productionTh_c_iteration(ccs,t,d);
            !            	   k_CCS_p_iteration(ccs,t,d,l+1)				:= k_CCS_c_iteration(ccs,t,d);
            !
            !            	   o5_r(ccs,t,d,l)						:= r_.Level(ccs,t,d);
            !            	   o5_RAS_level(f,ccs,t,d,l) 					:= RAS_level.Level(ccs,t,d);
            !                   o5_RAS_charge(f,ccs,t,d,l) 					:= RAS_charge.Level(ccs,t,d);
            !                   o5_RAS_discharge(f,ccs,t,d,l) 				:= RAS_discharge.Level(ccs,t,d);
            !            	   o5_bypass(f,ccs,t,d,l) 				  	:= bypass_.Level(ccs,t,d);
            
                        	  endfor; ! end of the l loop
            
                        	DemandProfiles_dynamic(d) :=no;
            
                                  endfor ;! end of the d loop
            
                                  elseif (optimis_horizon_option=4) then
                        	! we loop over our clustered days, setting each element of dd to yes in turn
                        	 ! so that all of the above equations focus on one cluster at a time...
            
                                DemandProfiles_dynamic(d) :=no;
                                 for (d) do ! cluster loop
                                  DemandProfiles_dynamic(d) :=yes;
            
                                  for (l) do !iteration loop
            
            !                    	r_for_calculation(ccs,t,d)				:= r_p_iteration(ccs,t,d,l);
            !            		RAS_discharge_for_calculation(ccs,t,d)			:= RAS_discharge_p_iteration(ccs,t,d);
            !            		RAS_charge_r_for_calculation(ccs,t,d)			:= RAS_charge_r_p_iteration(ccs,t,d);
            !            		bypass_for_calculation(ccs,t,d)				:= bypass_p_iteration(ccs,t,d);
            !
            !            		productionTh_for_calculation(ccs,t,d) 			:= productionTh_p_iteration(ccs,t,d,l);
            !            		k_CCS_for_calculation(ccs,t,d)				:= k_CCS_p_iteration(ccs,t,d,l);
            !
            !            penalty_CCS(ccs,t,d) := 
            !            alpha * RAS_discharge_for_calculation(ccs,t,d) * k_CCS_for_calculation(ccs,t,d) * plant(ccs,'CC_FIXED')/1000 + !CCS penalty
            !            !(plant(ccs,'CC_OP')/1000) * RAS_discharge_productionTh_for_calculation(ccs,t,d) * plant(ccs,'CO2') * 1000 * r_for_calculation(ccs,t,d) +
            !             plant(ccs,'CC_OP')/1000  * productionTh_for_calculation(ccs,t,d) 		* plant(ccs,'CO2') * 1000 * r_for_calculation(ccs,t,d) +
            !            !	RAS_charge_k_CCS_for_calculation(ccs,t,d)    * plant(ccs,'CC_FIXED')/1000 -
            !            (plant(ccs,'CC_OP')/1000) * productionTh_for_calculation(ccs,t,d)    * plant(ccs,'CO2') * 1000 * RAS_charge_r_for_calculation(ccs,t,d) + 
            !            k_CCS_for_calculation(ccs,t,d)        				* Fixed_Capture_Penalty/1000 - 
            !            bypass_for_calculation(ccs,t,d) * k_CCS_for_calculation(ccs,t,d) * Fixed_Capture_Penalty/1000 +
            !            k_CCS_for_calculation(ccs,t,d) 		 	     * plant(ccs,'CC_FIXED')/1000;
            !
                                   Solve vitali where MIP_Relative_Optimality_Tolerance :=rel_opt_tol, time_limit := lim_exec_time; ! activate this if it is set manually in MainInitialization
            
                                   Online_end_1(g,d+1)		:=Online.Level(g,'167',d);
                                   Online_end(g,d+1)		:=Online.Level(g,'168',d);
                                   Online_end_2(g,d+1)		:=Online.Level(g,'166',d);
                                   Online_end_3(g,d+1)		:=Online.Level(g,'165',d);
                                   Output_end(g,d+1)     		:=output_.Level(g,'168',d);
            
                                ! integer shadow prices for meeting just demand
                                  o5_D_marginals(f,t,d,l) 				:= eqDemandMet.ShadowPrice(t,d)/1000 ; ! to make it /MWh
                                ! shadow prices for energy plus reserve = electricity price
                                  o5_D_S_marginals(f,t,d,l) 			:= (eqDemandMet.ShadowPrice(t,d) + eqSpinningMet.ShadowPrice(t,d))/1000 ;! to make it /MWh
                                  lambda(t,d) 					:= o5_D_S_marginals(f,t,d,l);
                                  o5_costResults(f,d,l)				:= totalCost.Level;
                                  o5_outputResults_base(f,g,t,d,l)			:= output_.Level(g,t,d);
                                  o5_outputResults_net(f,g,t,d,l)			:= output_.Level(g,t,d);                                            
                                  o5_outputResults_net(f,pccs,t,d,l)		:= output_.Level(pccs,t,d) - Penalty_PCCS.Level(pccs,t,d);
                                  o5_outputResults_net(f,ac,t,d,l)			:= output_.Level(ac,t,d) - Penalty_AC_positive.Level(ac,t,d) + Penalty_AC_negative.Level(ac,t,d);
                                  o5_outputResults_net(f,sg,t,d,l)			:= output_.Level(sg,t,d) * storageDischargeEff(sg) - storageInput.Level(sg,t,d);
                                  o5_Capacity_StartedResults(f,g,t,d,l)		:= Started.Level(g,t,d);
                                  o5_Capacity_StoppedResults(f,g,t,d,l)		:= Stopped.Level(g,t,d);
                                  o5_Capacity_OnlineResults(f,g,t,d,l)		:= Online.Level(g,t,d);
                                  !o5_dailyCostResults(f,d)				:= dailyCost.Level(d);
                                  o5_storageInputResults(f,sg,t,d,l)		:= storageInput.Level(sg,t,d);
                                  o5_storageLevelResults(f,sg,t,d,l)		:= storageLevel.Level(sg,t,d);
                                  o5_eqMinLimit(f,g,t,d,l)				:= eqMinLimit.ShadowPrice(g,t,d);
                                  o5_eqMaxLimit(f,g,t,d,l)				:= eqMaxLimit.ShadowPrice(g,t,d);
                                  o5_eqDiffUPRamp(f,g,t,d,l)			:= eqDiffUPRamp.ShadowPrice(g,t,d);
                                  o5_eqDiffUPRamp_initial(f,g,d,l)			:= eqDiffUPRamp_initial.ShadowPrice(g,d);
                                  o5_eqDiffDNRamp(f,g,t,d,l)			:= eqDiffDNRamp.ShadowPrice(g,t,d);
                                  o5_eqDiffDNRamp_initial(f,g,d,l)			:= eqDiffDNRamp_initial.ShadowPrice(g,d);
                                  o5_eqRampUP(f,g,t,d,l)				:= eqRampUP.ShadowPrice(g,t,d);
                                  o5_eqRampDN(f,g,t,d,l)				:= eqRampDN.ShadowPrice(g,t,d);
                                  o5_reserve_UP(f,drg,t,d,l)			:= Online.Level(drg,t,d) * plant(drg, 'MaxPower') - output_.Level(drg,t,d);
                                  o5_reserve_UP(f,sg,t,d,l)				:= storageDischargeEff(sg) * (sg_Online_availLevel.Level(sg,t,d) - output_.Level(sg,t,d));
            		      o5_carbon_intensity_hour(f,t,d)			:= 1000 * (sum(nccs, 1000 * output_.Level(nccs,t,d) * plant(nccs,'CO2') * 1/plant(nccs,'GINC')) + sum(ccs, 1000 * output_.Level(ccs,t,d) * plant(ccs,'CO2') * (1/plant(ccs,'GINC')) * (1 - plant(ccs,'Y_MAX_CAPT')))) / (sum(nccs, 1000 * output_.Level(nccs,t,d)) + sum(ccs, 1000 * output_.Level(ccs,t,d)));
            		      o5_Status_DT(f,g,t,d,l)				:= Status_DT.Level(g,t,d);
            
                        	      o5_penalty_level(f,pccs,t,d,l)			:= penalty_CCS(pccs,t,d);
            
                                  o5_heat_continuation(f,d,t,ac,l)				:= heat_continuation.Level(ac,t,d);
                                  o5_charging(f,d,t,sg,l)				:= charging.Level(sg,t,d);
                                  o5_discharging(f,d,t,sg,l)			:= discharging.Level(sg,t,d);
                                  o5_Penalty_AC(f,d,t,ac,l)				:= Penalty_AC_positive.Level(ac,t,d) + Penalty_AC_negative.Level(ac,t,d);
                                  o5_Oxy_tank_level(f,d,t,ac,l)			:= Oxy_tank_level.Level(ac,t,d);
                                  o5_tank_leakage(f,d,t,ac,l)			:= tank_leakage(ac,t,d);
                                  o5_Penalty_PCCS(f,d,t,pccs,l)			:= Penalty_PCCS.Level(pccs,t,d);
            
            
            !            	  output_c_iteration(ccs,t,d) 					:= output_.Level(ccs,t,d);
            !            	  productionTh_c_iteration(ccs,t,d)				:= productionTh.Level(ccs,t,d);
            !            	  price_c_iteration(t,d)					:= o5_D_S_marginals(f,t,d,l);
            !            	  k_CCS_c_iteration(ccs,t,d)					:= k_CCS.Level(ccs,t,d);
            !
            !            	   Solve CCS_profit;
            !                   r_p_iteration(ccs,t,d,l+1)					:= r_.Level(ccs,t,d);
            !            	   RAS_discharge_p_iteration(ccs,t,d)				:= RAS_discharge.Level(ccs,t,d);
            !            	   RAS_charge_r_p_iteration(ccs,t,d)				:= RAS_charge_r.Level(ccs,t,d);
            !            	   bypass_p_iteration(ccs,t,d)					:= bypass_.Level(ccs,t,d);
            !
            !            	   productionTh_p_iteration(ccs,t,d,l+1)			:= productionTh_c_iteration(ccs,t,d);
            !            	   k_CCS_p_iteration(ccs,t,d,l+1)				:= k_CCS_c_iteration(ccs,t,d);
            !
            !            	   o5_r(ccs,t,d,l)						:= r_.Level(ccs,t,d);
            !            	   o5_RAS_level(f,ccs,t,d,l) 					:= RAS_level.Level(ccs,t,d);
            !                   o5_RAS_charge(f,ccs,t,d,l) 					:= RAS_charge.Level(ccs,t,d);
            !                   o5_RAS_discharge(f,ccs,t,d,l) 				:= RAS_discharge.Level(ccs,t,d);
            !            	   o5_bypass(f,ccs,t,d,l) 				  	:= bypass_.Level(ccs,t,d);
            
                        	  endfor; ! end of the l loop
            
                        	DemandProfiles_dynamic(d) :=no;
            
                                  endfor ;! end of the d loop
                              endif;!end of if statement
            endfor ;! end of the f loop
            endblock;
            
            Block ! Carbon calculations
            CarbonInc(f,l) 					:= sum((nccs,t,d),1000 * o5_outputResults_base(f,nccs,t,d,l)	* (plant(nccs,'CO2') * (1/plant(nccs,'GINC')))) + !from non-CCS plants
            	          				   sum((ccs,t,d), 1000 * o5_outputResults_base(f,ccs,t,d,l)	* (plant(ccs,'CO2')  * (1/plant(ccs,'GINC'))  * (1 - plant(ccs,'Y_MAX_CAPT')))); ! from CCS plants
            CarbonStartShut(f,l) 				:= sum((g,t,d),plant(g,'GSU_CO2_COLD') * o5_Capacity_StartedResults(f,g,t,d,l)) + 
            						   sum((g,t,d),plant(g,'GSH_CO2')      * o5_Capacity_StoppedResults(f,g,t,d,l));
            TotalCarbon(f,l) 				:= CarbonInc(f,l) + CarbonStartShut(f,l);
            TotalSupply(f,l)				:= sum((nccs,t,d),o5_outputResults_base(f,nccs,t,d,l)) + sum((ccs,t,d),o5_outputResults_base(f,ccs,t,d,l));
            o5_carbon_intensity_period(f,l)			:= CarbonInc(f,l) / TotalSupply(f,l); 
            o5_carbon_intensity_period_SUSD(f,l)		:= (CarbonInc(f,l) + CarbonStartShut(f,l)) / TotalSupply(f,l);
            ! total capacity of each plant type (MW)
            TotalCapacity(g) 				:= plant(g,'maxPower') * 1000;
            o5_storageEndAverage2(f,sg,l)			:=sum(d,o5_storageLevelResults(f,sg,_24_,d,l))/card(DemandProfiles);
             EndBlock ;
            
            Block ! Generete outputs.
                                if (xlsResults = 1) then
                                o5_general_parameters(f,d,t,l,'Demand (GW)')                      				:=demand(t,d);
                                 o5_general_parameters(f,d,t,l,'Output (GW)')                      				:=sum(rg, o5_outputResults_net(f,rg,t,d,l));
            
                                ! available spinning capacity is the sum of all physical generators online, plus any output from load shedding
                                 o5_general_parameters(f,d,t,l,'Spinning Capacity (GW)')    				:=sum(rg,o5_Capacity_OnlineResults(f,rg,t,d,l)) + sum(cg,o5_outputResults_net(f,cg,t,d,l));
                                 o5_general_parameters(f,d,t,l,'Storage Spinning (GW)')     				:=sum(sg,o5_Capacity_OnlineResults(f,sg,t,d,l));
                                 o5_general_parameters(f,d,t,l,'Start ups')                 				:=sum(rg,o5_Capacity_StartedResults(f,rg,t,d,l)) - sum(sg,o5_Capacity_StartedResults(f,sg,t,d,l));
                                 o5_general_parameters(f,d,t,l,'Shut downs')                				:=sum(rg,o5_Capacity_StoppedResults(f,rg,t,d,l)) - sum(sg,o5_Capacity_StoppedResults(f,sg,t,d,l));
                                 o5_general_parameters(f,d,t,l,'Storage Output')            				:=sum(sg,o5_outputResults_net(f,sg,t,d,l));
                                 o5_general_parameters(f,d,t,l,'Storage Input')             				:=sum(sg,o5_storageInputResults(f,sg,t,d,l));
                                 o5_general_parameters(f,d,t,l,'Storage Level')             				:=sum(sg,o5_storageLevelResults(f,sg,t,d,l));
                                 o5_general_parameters(f,d,t,l,'Total Cost (pondm)')           				:=o5_costResults(f,d,l);
                                 o5_general_parameters(f,d,t,l,'Incremental Cost (pond/MWh)')  				:=o5_D_marginals(f,t,d,l) * 1000;
                                 o5_general_parameters(f,d,t,l,'Marginal Cost (pond/MWh)')     				:=o5_D_S_marginals(f,t,d,l) * 1000;
            
                                ! convert all zeros into epsilon values, so that they can be passed into into excel...
                                 o5_Capacity_OnlineResults(f,g,t,d,l) $ (o5_Capacity_OnlineResults(f,g,t,d,l) = 0) 		:=zero;
                                 o5_Capacity_StartedResults(f,g,t,d,l) $ (o5_Capacity_StartedResults(f,g,t,d,l) = 0) 	:=zero;
                                 o5_Capacity_StoppedResults(f,g,t,d,l) $ (o5_Capacity_StoppedResults(f,g,t,d,l) = 0) 	:=zero;
                                 o5_outputResults_base(f,g,t,d,l) $ (o5_outputResults_base(f,g,t,d,l) = 0) 			:=zero;
                                 o5_outputResults_net(f,g,t,d,l) $ (o5_outputResults_net(f,g,t,d,l) = 0) 			:=zero;
                                 o5_storageInputResults(f,sg,t,d,l) $ (o5_storageInputResults(f,sg,t,d,l) = 0) 		:=zero;
                                 o5_storageLevelResults(f,sg,t,d,l) $ (o5_storageLevelResults(f,sg,t,d,l) = 0) 		:=zero;
                                 o5_eqMinLimit(f,g,t,d,l) $ (o5_eqMinLimit(f,g,t,d,l)=0)					:=zero;
                                 o5_eqMaxLimit(f,g,t,d,l) $ (o5_eqMaxLimit(f,g,t,d,l)=0)					:=zero;
                                 o5_eqDiffUPRamp(f,g,t,d,l) $ (o5_eqDiffUPRamp(f,g,t,d,l)=0)				:=zero;
                                 o5_eqDiffUPRamp_initial(f,g,d,l) $ (o5_eqDiffUPRamp_initial(f,g,d,l)=0)			:=zero;
                                 o5_eqDiffDNRamp(f,g,t,d,l) $ (o5_eqDiffDNRamp(f,g,t,d,l)=0)				:=zero;
                                 o5_eqDiffDNRamp_initial(f,g,d,l) $ (o5_eqDiffDNRamp_initial(f,g,d,l)=0)			:=zero;
                                 o5_eqRampUP(f,g,t,d,l)$(o5_eqRampUP(f,g,t,d,l)=0)						:=zero;	
                                 o5_eqRampUP_initial(f,g,d,l)$(o5_eqRampUP_initial(f,g,d,l)=0)				:=zero;		
                                 o5_eqRampDN(f,g,t,d,l)$(o5_eqRampDN(f,g,t,d,l)=0)						:=zero;		
                                 o5_eqRampDN_initial(f,g,d,l)$(o5_eqRampDN_initial(f,g,d,l)=0)				:=zero;		
                                 o5_reserve_UP(f,g,t,d,l)$ (o5_reserve_UP(f,g,t,d,l)=0)					:=zero;
                                 o5_Status_DT(f,g,t,d,l)$(o5_Status_DT(f,g,t,d,l)=0)					:=zero;
                                 o5_heat_continuation(f,d,t,ac,l)$(o5_heat_continuation(f,d,t,ac,l)=0)			:=zero;
                                 o5_charging(f,d,t,sg,l)$(o5_charging(f,d,t,sg,l)=0)					:=zero;
                                 o5_discharging(f,d,t,sg,l)$(o5_discharging(f,d,t,sg,l)=0)					:=zero;
                                 o5_Penalty_AC(f,d,t,ac,l)$(o5_Penalty_AC(f,d,t,ac,l)=0)					:=zero;
                                 o5_Oxy_tank_level(f,d,t,ac,l)$(o5_Oxy_tank_level(f,d,t,ac,l)=0)				:=zero;
                                 o5_tank_leakage(f,d,t,ac,l)$(o5_tank_leakage(f,d,t,ac,l)=0)				:=zero;
                                 o5_Penalty_PCCS(f,d,t,pccs,l)$(o5_Penalty_PCCS(f,d,t,pccs,l)=0)				:=zero;
                                 o5_statsOnline(f,d,t,g,l)   								:=o5_Capacity_OnlineResults(f,g,t,d,l);
                                 o5_statsStarts(f,d,t,g,l)   								:=o5_Capacity_StartedResults(f,g,t,d,l); 
                                 o5_statsStops(f,d,t,g,l)    								:=o5_Capacity_StoppedResults(f,g,t,d,l);
                                 o5_statsStartsStops(f,d,t,g,l) 								:=o5_Capacity_StartedResults(f,g,t,d,l) + o5_Capacity_StoppedResults(f,g,t,d,l);	
                                 o5_statsOutput_net(f,d,t,g,l)   								:=o5_outputResults_net(f,g,t,d,l);
                                 o5_statsOutput_base(f,d,t,g,l)								:=o5_outputResults_base(f,g,t,d,l);
                                 o5_statsInput(f,d,t,sg,l)   								:=o5_storageInputResults(f,sg,t,d,l);
                                 o5_statsStorage(f,d,t,sg,l) 								:=o5_storageLevelResults(f,sg,t,d,l);
                                 o5_ave_storage_level(f,sg)									:=o5_storageEndAverage(f,sg);
                                 o5_statsReserve_UP(f,d,t,g,l)								:=o5_reserve_UP(f,g,t,d,l);
                                 o5_marginal_eqMinLimit(f,d,t,g,l)								:=o5_eqMinLimit(f,g,t,d,l);
                                 o5_marginal_eqMaxLimit(f,d,t,g,l)								:=o5_eqMaxLimit(f,g,t,d,l);
                                 o5_marginal_eqDiffUPRamp(f,d,t,g,l)							:=o5_eqDiffUPRamp(f,g,t,d,l);
                                 o5_marginal_eqDiffUPRamp_initial(f,d,g,l)							:=o5_eqDiffUPRamp_initial(f,g,d,l);
                                 o5_marginal_eqDiffDNRamp(f,d,t,g,l)							:=o5_eqDiffDNRamp(f,g,t,d,l);
                                 o5_marginal_eqDiffDNRamp_initial(f,d,g,l)							:=o5_eqDiffDNRamp_initial(f,g,d,l);
                                 o5_marginal_eqRampUP(f,d,t,g,l)								:=o5_eqRampUP(f,g,t,d,l);
                                 o5_marginal_eqRampUP_initial(f,d,g,l)							:=o5_eqRampUP_initial(f,g,d,l);
                                 o5_marginal_eqRampDN(f,d,t,g,l)								:=o5_eqDiffDNRamp(f,g,t,d,l);
                                 o5_marginal_eqRampDN_initial(f,d,g,l)							:=o5_eqRampDN_initial(f,g,d,l);
                                !o5_optimised_rate(ccs,f,t,d)								:=o5_capture_rate(ccs,f,t,d);
            		     o5_large_solar_curtailment(f,d,t,l)							:= plant('Large_Solar','MaxPower') * solar_LF(t,d) - o5_statsOutput_base(f,d,t,'Large_Solar',l);
                        	     o5_small_solar_curtailment(f,d,t,l)							:= plant('Small_Solar','MaxPower') * solar_LF(t,d) - o5_statsOutput_base(f,d,t,'Small_Solar',l);
                        	     o5_onshore_wind_curtailment(f,d,t,l)							:= plant('Onshore_Wind','MaxPower') * wind_LF(t,d) - o5_statsOutput_base(f,d,t,'Onshore_Wind',l);
                        	     o5_offshore_wind_curtailment(f,d,t,l)							:= plant('Offshore_Wind','MaxPower') * wind_LF(t,d) - o5_statsOutput_base(f,d,t,'Offshore_Wind',l);
                        	     o5_Status_down(f,d,t,g,l)									:= o5_Status_DT(f,g,t,d,l);
                                 endif ;
                            EndBlock ;
            
            Block ! retrieving math program descriptors
                            o5_math_program_numbers('Objective_') :=vitali.Objective;
                            o5_math_program_numbers('LinearObjective') :=vitali.LinearObjective;
                            o5_math_program_numbers('Incumbent') :=vitali.Incumbent;
                            o5_math_program_numbers('BestBound') :=vitali.bestbound;
                            o5_math_program_string('ProgramStatus') :=vitali.ProgramStatus;
                            o5_math_program_string('SolverStatus') :=vitali.SolverStatus;
                            o5_math_program_numbers('Iterations') :=vitali.Iterations;
                            o5_math_program_numbers('Nodes_') :=vitali.Nodes;
                            o5_math_program_numbers('GenTime') :=vitali.GenTime;
                            o5_math_program_numbers('SolutionTime') :=vitali.SolutionTime;
                            o5_math_program_numbers('NumberOfBranches') :=vitali.NumberOfBranches;
                            o5_math_program_numbers('NumberOfFails') :=vitali.NumberOfFails;
                            o5_math_program_numbers('NumberOfInfeasibilities') :=vitali.NumberOfInfeasibilities;
                            o5_math_program_numbers('SumOfInfeasibilities') :=vitali.SumOfInfeasibilities;
                            o5_math_program_numbers('SolverCalls') :=vitali.SolverCalls;
                            o5_math_program_numbers('NumberOfConstraints') :=vitali.NumberOfConstraints;
                            o5_math_program_numbers('NumberOfVariables') :=vitali.NumberOfVariables;
                            o5_math_program_numbers('NumberOfNonzeros') :=vitali.NumberOfNonzeros;
                            o5_math_program_numbers('NumberOfIntegerVariables') :=vitali.NumberOfIntegerVariables;
                            o5_math_program_numbers('NumberOfSOS1Constraints') :=vitali.NumberOfSOS1Constraints;
                            o5_math_program_numbers('NumberOfSOS2Constraints') :=vitali.NumberOfSOS2Constraints;
                            o5_math_program_numbers('NumberOfNonlinearConstraints') :=vitali.NumberOfNonlinearConstraints;
                            o5_math_program_numbers('NumberOfNonlinearVariables') :=vitali.NumberOfNonlinearVariables;
                            o5_math_program_numbers('NumberOfNonlinearNonzeros') :=vitali.NumberOfNonlinearNonzeros;
                            o5_math_program_numbers('NumberOfNonlinearInstructions') :=vitali.NumberOfNonlinearInstructions;
            EndBlock;
        }
    }
    Procedure RunExternalProcedure {
        Body: {
            CSVExport('o5_D_marginals');
            CSVExport('o5_D_S_marginals');
            CSVExport('o5_costResults');
            CSVExport('o5_outputResults_base');
            CSVExport('o5_outputResults_net');
            CSVExport('o5_Capacity_StartedResults');
            CSVExport('o5_Capacity_StoppedResults');
            CSVExport('o5_Capacity_OnlineResults');
            CSVExport('o5_dailyCostResults');
            CSVExport('o5_storageInputResults');
            CSVExport('o5_storageLevelResults');
            CSVExport('o5_sL');
            CSVExport('o5_statsOnline');
            CSVExport('o5_statsStarts');
            CSVExport('o5_statsStops');
            CSVExport('o5_statsStartsStops');
            CSVExport('o5_statsOutput_base');
            CSVExport('o5_statsOutput_net');
            CSVExport('o5_statsInput');
            CSVExport('o5_statsStorage');
            CSVExport('o5_general_parameters');
            CSVExport('o5_ave_storage_level');
            CSVExport('o5_marginal_eqMinLimit');
            CSVExport('o5_marginal_eqMaxLimit');
            CSVExport('o5_marginal_eqDiffUPRamp');
            CSVExport('o5_marginal_eqDiffUPRamp_initial');
            CSVExport('o5_marginal_eqDiffDNRamp');
            CSVExport('o5_marginal_eqDiffDNRamp_initial');
            CSVExport('o5_statsReserve_UP');
            CSVExport('o5_marginal_eqRampUP');
            CSVExport('o5_marginal_eqRampUP_initial');
            CSVExport('o5_marginal_eqRampDN');
            CSVExport('o5_marginal_eqRampDN_initial');
            CSVExport('o5_large_solar_curtailment');
            CSVExport('o5_small_solar_curtailment');
            CSVExport('o5_onshore_wind_curtailment');
            CSVExport('o5_offshore_wind_curtailment');
            CSVExport('o5_carbon_intensity_hour');
            CSVExport('o5_carbon_intensity_period');
            CSVExport('o5_carbon_intensity_period_SUSD');
            CSVExport('o5_Status_down');
            CSVExport('o5_heat_continuation');
            CSVExport('o5_charging');
            CSVExport('o5_discharging');
            CSVExport('o5_Penalty_AC');
            CSVExport('o5_Oxy_tank_level');
            CSVExport('o5_tank_leakage');
            CSVExport('o5_Penalty_PCCS');
            CSVExport('o5_math_program_numbers');
        }
    }
    Procedure MPStringExport {
        Body: {
            write o5_math_program_string to file "o5_math_program_string.out" ;
            write  GeneratorTypes to file "GeneratorTypes.out" ;
        }
    }
    ExternalProcedure CSVExport {
        Arguments: (param,location);
        DllName: CSVExportDllName;
        BodyCall: {
            CSVExport(
              scalar string : param,
              scalar string : location
            )
        }
        ElementParameter param {
            Range: AllIdentifiers;
            Property: Input;
        }
        StringParameter location {
            Default: ".";
            Property: Optional;
        }
    }
    Procedure ViewOutput {
        Body: {
            FileView("o5_math_program_string.out");
            FileView("o5_math_program_numbers.csv");
        }
    }
    Procedure MainTermination {
        Body: {
            return 1;
        }
    }
    Module Scenario_Generation_Module {
        Prefix: ScenGen;
        Section Callback_Function_References {
            DeclarationSection Declaration_Scenario_Generation_by_Data {
                ElementParameter InitializeStochasticScenarioDataCallbackFunction {
                    Range: AllIdentifiers;
                    Default: 'ScenGen::InitializeStochasticScenarioDataCallback';
                }
                ElementParameter CompareScenariosCallbackFunction {
                    Range: AllIdentifiers;
                    Default: 'ScenGen::CompareScenariosCallback';
                }
                ElementParameter DetermineScenarioGroupsCallbackFunction {
                    Range: AllIdentifiers;
                    Default: 'ScenGen::DetermineScenarioGroupsCallback';
                }
                ElementParameter AssignStochasticDataForScenarioGroupCallbackFunction {
                    Range: AllIdentifiers;
                    Default: 'ScenGen::AssignStochasticDataForScenarioGroupCallback';
                }
            }
        }
        Section Public_Section {
            DeclarationSection Public_Declarations {
                Set AllScenarios {
                    SubsetOf: AllStochasticScenarios;
                    Index: s, s2;
                    OrderBy: user;
                    Comment: "AllStochasticScenarios";
                }
                Set AllStages {
                    SubsetOf: Integers;
                    Index: st, st2;
                }
                ElementParameter ScenarioGenerationTreeMapping {
                    IndexDomain: (s,st);
                    Range: AllScenarios;
                }
                Parameter ScenarioGenerationProbability {
                    IndexDomain: (s);
                    Default: 0;
                }
            }
        }
        Section Scenario_Generation_by_Tree {
            Section Scenarion_Tree_Creation_Procedures_by_Tree;
            Section Callback_Procedures_by_Tree;
        }
        Section Scenario_Generation_by_Data {
            Section Scenarion_Tree_Creation_Procedures_by_Data {
                Procedure CreateScenarioData {
                    Arguments: (Stages,Scenarios,ScenarioProbability,ScenarioTreeMapping);
                    Body: {
                        empty AllScenarios;
                        cleandependents AllScenarios;
                        
                        AllStages := Stages;
                        
                        while ( 1 ) do
                            SetElementAdd( AllScenarios, NewScenario, FormatString("Scen-%i",card(AllScenarios)+1) );
                            GeneratedScenario := NewScenario;
                        
                            ScenarioWeight := Apply( InitializeStochasticScenarioDataCallbackFunction, NewScenario, AllScenarios );
                            break when not ScenarioWeight;
                        
                            if ( NewScenario <> GeneratedScenario ) then
                                AllScenarios -= GeneratedScenario;
                            endif;
                        
                            ScenarioGenerationProbability(NewScenario) := ScenarioWeight;
                        endwhile;
                        
                        AllStochasticScenarios -= NewScenario;
                        
                        block ! Normalize scenario probabilities
                            SumOfScenarioProbabilities := sum( s, ScenarioGenerationProbability(s) );
                        
                            if ( SumOfScenarioProbabilities > 0 ) then
                                ScenarioGenerationProbability(s) /= SumOfScenarioProbabilities;
                            endif;
                        endblock;
                        
                        GenerateScenarioTree;
                        
                        Scenarios := AllScenarios;
                        ScenarioProbability(sosc) := ScenarioGenerationProbability(sosc);
                        ScenarioTreeMapping(sosc,sost) := ScenarioGenerationTreeMapping(sosc,sost);
                    }
                    Set Stages {
                        SubsetOf: Integers;
                        Index: sost;
                        Property: Input;
                    }
                    Set Scenarios {
                        SubsetOf: AllStochasticScenarios;
                        Index: sosc;
                        Property: Output;
                        OrderBy: user;
                    }
                    Parameter ScenarioProbability {
                        IndexDomain: sosc;
                        Property: Output;
                    }
                    ElementParameter ScenarioTreeMapping {
                        IndexDomain: (sosc,sost);
                        Range: Scenarios;
                        Property: Output;
                    }
                    ElementParameter NewScenario {
                        Range: AllScenarios;
                    }
                    ElementParameter GeneratedScenario {
                        Range: AllScenarios;
                    }
                    Parameter ScenarioWeight;
                    Parameter SumOfScenarioProbabilities;
                }
                Procedure GenerateScenarioTree {
                    Body: {
                        ScenarioOrder(s) := 1;
                        
                        for ( st ) do
                            Scenario := First(AllScenarios);
                        
                            block !Subdivide all branches in stage st into child branches
                            while ( Scenario ) do
                                CurrentScenarioOrder := ScenarioOrder(Scenario);
                                NextScenario := First( s | ScenarioOrder(s) > CurrentScenarioOrder );
                                CurrentScenarioGroup := { s | ScenarioOrder(s) = CurrentScenarioOrder };
                                ! Callback to fill ScenarioOrder for all elements in CurrentScenarioGroup.
                                Apply( DetermineScenarioGroupsCallbackFunction, st, CurrentScenarioGroup, ScenarioOrder );
                                ScenarioOrder( s in CurrentScenarioGroup ) += CurrentScenarioOrder - 1;
                                Scenario := NextScenario;
                            endwhile;
                            endblock;
                        
                            ! Resort to group all scenarios that belong to the same group
                            AllScenarios := Sort( s, ScenarioOrder(s) );
                            Scenario := First(AllScenarios);
                            CurrentScenarioGroupCount := 0;
                            NewScenarioOrder(s) := ScenarioOrder(s);
                        
                            block !Assign identical stochastic data to all scenarios in the same group in stage st
                            while ( Scenario ) do
                                CurrentScenarioOrder := ScenarioOrder(Scenario);
                                NextScenario := First( s | ScenarioOrder(s) > CurrentScenarioOrder );
                                CurrentScenarioGroup := { s | ScenarioOrder(s) = CurrentScenarioOrder };
                                Apply( AssignStochasticDataForScenarioGroupCallbackFunction, st, CurrentScenarioGroup );
                                NewScenarioOrder( s in CurrentScenarioGroup ) += CurrentScenarioGroupCount - CurrentScenarioOrder + 1;
                                CurrentScenarioGroupCount += card( CurrentScenarioGroup );
                                Scenario := NextScenario;
                            endwhile;
                            endblock;
                        
                            ScenarioOrder(s) := NewScenarioOrder(s);
                        endfor;
                        
                        RemoveIdenticalScenarios;
                    }
                    ElementParameter NextScenario {
                        Range: AllScenarios;
                    }
                    Parameter ScenarioCount;
                    Parameter ScenarioOrder {
                        IndexDomain: (s);
                        Default: 1;
                    }
                    ElementParameter Scenario {
                        Range: AllScenarios;
                    }
                    ElementParameter FirstDifferentStage {
                        Range: AllStages;
                    }
                    Parameter NewScenarioOrder {
                        IndexDomain: (s);
                    }
                    Parameter CurrentScenarioOrder;
                    Set CurrentScenarioGroup {
                        SubsetOf: AllScenarios;
                    }
                    Parameter CurrentScenarioGroupCount;
                }
                Procedure RemoveIdenticalScenarios {
                    Arguments: ReorderScenarios;
                    Body: {
                        for (s) do
                            if ( Apply( CompareScenariosCallbackFunction, s, s+1, AllStages, FirstDifferentStage ) = 0 ) then
                                ScenarioGenerationProbability(s+1) += ScenarioGenerationProbability(s);
                                ScenarioGenerationProbability(s) := 0;
                            endif;
                        endfor;
                        
                        AllScenarios -= { s | ScenarioGenerationProbability(s) = 0 };
                        
                        if ( ReorderScenarios ) then
                            for (s) do
                                SetElementRename( AllScenarios, s, FormatString("Scenario-%i",ord(s)) );
                            endfor;
                        endif;
                        
                        ScenarioGenerationTreeMapping(s,st) := s;
                        
                        for (s | ord(s) > 1) do
                            Apply( CompareScenariosCallbackFunction, s-1, s, AllStages, FirstDifferentStage );
                            ScenarioGenerationTreeMapping((s,st) | st<FirstDifferentStage) := ScenarioGenerationTreeMapping(s-1,st);
                        endfor;
                    }
                    ElementParameter FirstDifferentStage {
                        Range: AllStages;
                    }
                    Parameter ReorderScenarios {
                        Range: binary;
                        Default: 0;
                        Property: Optional;
                    }
                }
            }
            Section Callback_Procedures_by_Data {
                Procedure InitializeStochasticScenarioDataCallback {
                    Arguments: (Scenario,Scenarios);
                    Body: {
                        return /*last scenario  */ 0;
                    }
                    Comment: {
                        "Initialize stochastic data for all periods corresponding to the current stage
                        (and scenario). The stochastic data for the first stage should be equal for all
                        scenarios."
                    }
                    ElementParameter Scenario {
                        Range: AllScenarios;
                        Property: InOut;
                    }
                    Set Scenarios {
                        SubsetOf: AllStochasticScenarios;
                        Index: cs;
                        Property: Input;
                    }
                }
                Procedure DetermineScenarioGroupsCallback {
                    Arguments: (CurrentStage,ScenarioGroup,ScenarioGroupOrder);
                    Comment: {
                        "This function should subdivide all scenarios into the set CurrentScenarioGroup into subgroups.
                        To do so the parameter CurrentScenarioGroupOrder should be initialized for every scenario in
                        this group with an integer number between 1 and the number of subgroups."
                    }
                    Parameter ScenarioOrder;
                    Parameter ScenarioAssignedToGroup {
                        IndexDomain: (sg);
                    }
                    ElementParameter CurrentStage {
                        Range: AllStages;
                        Property: Input;
                    }
                    ElementParameter Scenario {
                        Range: AllScenarios;
                    }
                    Set ScenarioGroup {
                        SubsetOf: AllScenarios;
                        Index: sg;
                        Property: Input;
                    }
                    Parameter ScenarioGroupOrder {
                        IndexDomain: (sg);
                        Range: {
                            {1..ScenarioGroupSize}
                        }
                        Default: 1;
                        Property: Output;
                    }
                    Parameter ScenarioGroupSize;
                }
                Procedure AssignStochasticDataForScenarioGroupCallback {
                    Arguments: (CurrentStage,ScenarioGroup);
                    ElementParameter CurrentStage {
                        Range: AllStages;
                        Property: Input;
                    }
                    Set ScenarioGroup {
                        SubsetOf: AllScenarios;
                        Index: sg;
                        Property: Input;
                    }
                    Parameter StochasticDateScenarioGroup;
                }
                Procedure CompareScenariosCallback {
                    Arguments: (Scenario1,Scenario2,Stages,FirstDifferentStage);
                    Body: {
                        return 0;
                    }
                    Comment: {
                        "This function should return 0 if the stochastic data for scenario1 and scenario2
                        is identical. Otherwise it should return nonzero and the first stage at which
                        both scenarios differ"
                    }
                    ElementParameter Scenario1 {
                        Range: AllScenarios;
                        Property: Input;
                    }
                    ElementParameter Scenario2 {
                        Range: AllScenarios;
                        Property: Input;
                    }
                    Set Stages {
                        SubsetOf: Integers;
                        Index: cs;
                        Property: Input;
                    }
                    ElementParameter FirstDifferentStage {
                        Range: Integers;
                        Property: Output;
                    }
                }
            }
        }
    }
    Module GMP_Outer_Approximation_Module {
        SourceFile: "%AIMMSMODULES%\\GMPOuterApproximation.ams";
        Comment: {
            "This module contains two outer approximation algorithms for solving Mixed Integer
            Nonlinear Problems (MINLP). The basic algorithm can be found in the section \'AOA
            Basic Algorithm\' and is based on the following two papers:
            
             M.A. Duran and I.E. Grossmann, An outer-approximation algorithm for a class of
             mixed-integer nonlinear programs, Mathematical Programming 36 (1986), pp. 307-339.
            
             J. Viswanathan and I.E. Grossmann, A combined penalty function and outer-approximation
             method for MINLP optimization, Computers and Chemical Engineering 14 (1990), pp. 769-778.
            
            The basic algorithm can be used for convex and non-convex problems with general integer
            variables.
            
            The section \'AOA Convex Algorithm\' contains a variant of the outer approximation algorithm
            that uses a single tree search. In this way the sequential solving of several MIP\'s is
            avoided. The algorithm is based on the paper:
            
             I. Quesada and I.E. Grossmann, An LP/NLP Based Branch and Bound Algorithm for Convex MINLP
             Optimization Problems, Computers and Chemical Engineering 16 (1992), pp. 937-947.
            
            This algorithm can only be used for convex problems (with general integer variables)."
        }
    }
    Module Outer_Approximation_Module {
        SourceFile: "%AIMMSMODULES%\\OuterApproximation.ams";
    }
    Module Multi_Start_Module {
        SourceFile: "%AIMMSMODULES%\\MultiStart.ams";
        Comment: {
            "The basic MultiStart algorithm:
            -------------------------------
            
            Input: GMP corresponding to the NLP problem, NumberOfSamplePoints, NumberOfSelectedSamplePoints.
            
            0.      Set IterationCount equal to 1.
            1.      Generate NumberOfSamplePoints sample points from the uniform distribution.
                    Calculate the penalized objective for all sample points and select the best
                    NumberOfSelectedSamplePoints sample points.
            2.      For all sample points (NumberOfSelectedSamplePoints in total) do:
            			For all clusters, calculate the distance between the sample point and the center
                    	of the cluster. If the distance is smaller than the radius of the cluster (i.e.,
                    	the sample point belongs to the cluster) then delete the sample point.
            3.      For all (remaining) sample points do:
            			Solve the NLP by using the sample point as its starting point to obtain a candidate
            			local solution.
                    	For all clusters do:
                    	a.	Calculate the distance between the candidate local solution and the local
                    		solution belonging to the cluster.
                		b.	If the distance equals 0 (which implies that the candidate local solution is the
                			same as the local solution belonging to the cluster) then update the center and
                			radius of the cluster by using the sample point.
                		c.	Else, construct a new cluster by using the mean of the sample point and the
                			candidate local solution as its center with radius equal to half the distance
                			between these two points. Assign the candidate local solution as the local
                			solution belonging to the cluster.
                		For all remaining sample points, calculate the distance between the sample point
                		and the center of the updated or the new cluster. If the distance is smaller
                		than the radius of the cluster then delete the sample point.
            4.      Increment IterationCount. If the number of iterations exceeds the IterationLimit,
                    then go to step (5). Else go to step (1).
            5.      Order the local solutions and store the NumberOfBestSolutions solutions in the
                    solution repository.
            
            By default, the algorithm uses the starting point as the first \"sample\" point in the first
            iteration.
            
            The algorithm deletes all initial solutions present in the solution repository of the GMP."
        }
    }
}